// Code generated by ent, DO NOT EDIT.

package ent

import (
	"agricoladb/ent/card"
	"agricoladb/ent/cardspecialcolor"
	"agricoladb/ent/cardtype"
	"agricoladb/ent/deck"
	"agricoladb/ent/predicate"
	"agricoladb/ent/product"
	"agricoladb/ent/revision"
	"errors"
	"fmt"
)

// CardWhereInput represents a where input for filtering Card queries.
type CardWhereInput struct {
	Predicates []predicate.Card  `json:"-"`
	Not        *CardWhereInput   `json:"not,omitempty"`
	Or         []*CardWhereInput `json:"or,omitempty"`
	And        []*CardWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "literal_id" field predicates.
	LiteralID             *string  `json:"literalID,omitempty"`
	LiteralIDNEQ          *string  `json:"literalIDNEQ,omitempty"`
	LiteralIDIn           []string `json:"literalIDIn,omitempty"`
	LiteralIDNotIn        []string `json:"literalIDNotIn,omitempty"`
	LiteralIDGT           *string  `json:"literalIDGT,omitempty"`
	LiteralIDGTE          *string  `json:"literalIDGTE,omitempty"`
	LiteralIDLT           *string  `json:"literalIDLT,omitempty"`
	LiteralIDLTE          *string  `json:"literalIDLTE,omitempty"`
	LiteralIDContains     *string  `json:"literalIDContains,omitempty"`
	LiteralIDHasPrefix    *string  `json:"literalIDHasPrefix,omitempty"`
	LiteralIDHasSuffix    *string  `json:"literalIDHasSuffix,omitempty"`
	LiteralIDEqualFold    *string  `json:"literalIDEqualFold,omitempty"`
	LiteralIDContainsFold *string  `json:"literalIDContainsFold,omitempty"`

	// "revision_id" field predicates.
	RevisionID      *int  `json:"revisionID,omitempty"`
	RevisionIDNEQ   *int  `json:"revisionIDNEQ,omitempty"`
	RevisionIDIn    []int `json:"revisionIDIn,omitempty"`
	RevisionIDNotIn []int `json:"revisionIDNotIn,omitempty"`

	// "printed_id" field predicates.
	PrintedID             *string  `json:"printedID,omitempty"`
	PrintedIDNEQ          *string  `json:"printedIDNEQ,omitempty"`
	PrintedIDIn           []string `json:"printedIDIn,omitempty"`
	PrintedIDNotIn        []string `json:"printedIDNotIn,omitempty"`
	PrintedIDGT           *string  `json:"printedIDGT,omitempty"`
	PrintedIDGTE          *string  `json:"printedIDGTE,omitempty"`
	PrintedIDLT           *string  `json:"printedIDLT,omitempty"`
	PrintedIDLTE          *string  `json:"printedIDLTE,omitempty"`
	PrintedIDContains     *string  `json:"printedIDContains,omitempty"`
	PrintedIDHasPrefix    *string  `json:"printedIDHasPrefix,omitempty"`
	PrintedIDHasSuffix    *string  `json:"printedIDHasSuffix,omitempty"`
	PrintedIDIsNil        bool     `json:"printedIDIsNil,omitempty"`
	PrintedIDNotNil       bool     `json:"printedIDNotNil,omitempty"`
	PrintedIDEqualFold    *string  `json:"printedIDEqualFold,omitempty"`
	PrintedIDContainsFold *string  `json:"printedIDContainsFold,omitempty"`

	// "play_agricola_card_id" field predicates.
	PlayAgricolaCardID             *string  `json:"playAgricolaCardID,omitempty"`
	PlayAgricolaCardIDNEQ          *string  `json:"playAgricolaCardIDNEQ,omitempty"`
	PlayAgricolaCardIDIn           []string `json:"playAgricolaCardIDIn,omitempty"`
	PlayAgricolaCardIDNotIn        []string `json:"playAgricolaCardIDNotIn,omitempty"`
	PlayAgricolaCardIDGT           *string  `json:"playAgricolaCardIDGT,omitempty"`
	PlayAgricolaCardIDGTE          *string  `json:"playAgricolaCardIDGTE,omitempty"`
	PlayAgricolaCardIDLT           *string  `json:"playAgricolaCardIDLT,omitempty"`
	PlayAgricolaCardIDLTE          *string  `json:"playAgricolaCardIDLTE,omitempty"`
	PlayAgricolaCardIDContains     *string  `json:"playAgricolaCardIDContains,omitempty"`
	PlayAgricolaCardIDHasPrefix    *string  `json:"playAgricolaCardIDHasPrefix,omitempty"`
	PlayAgricolaCardIDHasSuffix    *string  `json:"playAgricolaCardIDHasSuffix,omitempty"`
	PlayAgricolaCardIDIsNil        bool     `json:"playAgricolaCardIDIsNil,omitempty"`
	PlayAgricolaCardIDNotNil       bool     `json:"playAgricolaCardIDNotNil,omitempty"`
	PlayAgricolaCardIDEqualFold    *string  `json:"playAgricolaCardIDEqualFold,omitempty"`
	PlayAgricolaCardIDContainsFold *string  `json:"playAgricolaCardIDContainsFold,omitempty"`

	// "deck_id" field predicates.
	DeckID       *int  `json:"deckID,omitempty"`
	DeckIDNEQ    *int  `json:"deckIDNEQ,omitempty"`
	DeckIDIn     []int `json:"deckIDIn,omitempty"`
	DeckIDNotIn  []int `json:"deckIDNotIn,omitempty"`
	DeckIDIsNil  bool  `json:"deckIDIsNil,omitempty"`
	DeckIDNotNil bool  `json:"deckIDNotNil,omitempty"`

	// "card_type_id" field predicates.
	CardTypeID      *int  `json:"cardTypeID,omitempty"`
	CardTypeIDNEQ   *int  `json:"cardTypeIDNEQ,omitempty"`
	CardTypeIDIn    []int `json:"cardTypeIDIn,omitempty"`
	CardTypeIDNotIn []int `json:"cardTypeIDNotIn,omitempty"`

	// "card_special_color_id" field predicates.
	CardSpecialColorID       *int  `json:"cardSpecialColorID,omitempty"`
	CardSpecialColorIDNEQ    *int  `json:"cardSpecialColorIDNEQ,omitempty"`
	CardSpecialColorIDIn     []int `json:"cardSpecialColorIDIn,omitempty"`
	CardSpecialColorIDNotIn  []int `json:"cardSpecialColorIDNotIn,omitempty"`
	CardSpecialColorIDIsNil  bool  `json:"cardSpecialColorIDIsNil,omitempty"`
	CardSpecialColorIDNotNil bool  `json:"cardSpecialColorIDNotNil,omitempty"`

	// "name_ja" field predicates.
	NameJa             *string  `json:"nameJa,omitempty"`
	NameJaNEQ          *string  `json:"nameJaNEQ,omitempty"`
	NameJaIn           []string `json:"nameJaIn,omitempty"`
	NameJaNotIn        []string `json:"nameJaNotIn,omitempty"`
	NameJaGT           *string  `json:"nameJaGT,omitempty"`
	NameJaGTE          *string  `json:"nameJaGTE,omitempty"`
	NameJaLT           *string  `json:"nameJaLT,omitempty"`
	NameJaLTE          *string  `json:"nameJaLTE,omitempty"`
	NameJaContains     *string  `json:"nameJaContains,omitempty"`
	NameJaHasPrefix    *string  `json:"nameJaHasPrefix,omitempty"`
	NameJaHasSuffix    *string  `json:"nameJaHasSuffix,omitempty"`
	NameJaIsNil        bool     `json:"nameJaIsNil,omitempty"`
	NameJaNotNil       bool     `json:"nameJaNotNil,omitempty"`
	NameJaEqualFold    *string  `json:"nameJaEqualFold,omitempty"`
	NameJaContainsFold *string  `json:"nameJaContainsFold,omitempty"`

	// "name_en" field predicates.
	NameEn             *string  `json:"nameEn,omitempty"`
	NameEnNEQ          *string  `json:"nameEnNEQ,omitempty"`
	NameEnIn           []string `json:"nameEnIn,omitempty"`
	NameEnNotIn        []string `json:"nameEnNotIn,omitempty"`
	NameEnGT           *string  `json:"nameEnGT,omitempty"`
	NameEnGTE          *string  `json:"nameEnGTE,omitempty"`
	NameEnLT           *string  `json:"nameEnLT,omitempty"`
	NameEnLTE          *string  `json:"nameEnLTE,omitempty"`
	NameEnContains     *string  `json:"nameEnContains,omitempty"`
	NameEnHasPrefix    *string  `json:"nameEnHasPrefix,omitempty"`
	NameEnHasSuffix    *string  `json:"nameEnHasSuffix,omitempty"`
	NameEnIsNil        bool     `json:"nameEnIsNil,omitempty"`
	NameEnNotNil       bool     `json:"nameEnNotNil,omitempty"`
	NameEnEqualFold    *string  `json:"nameEnEqualFold,omitempty"`
	NameEnContainsFold *string  `json:"nameEnContainsFold,omitempty"`

	// "min_players_number" field predicates.
	MinPlayersNumber       *int  `json:"minPlayersNumber,omitempty"`
	MinPlayersNumberNEQ    *int  `json:"minPlayersNumberNEQ,omitempty"`
	MinPlayersNumberIn     []int `json:"minPlayersNumberIn,omitempty"`
	MinPlayersNumberNotIn  []int `json:"minPlayersNumberNotIn,omitempty"`
	MinPlayersNumberGT     *int  `json:"minPlayersNumberGT,omitempty"`
	MinPlayersNumberGTE    *int  `json:"minPlayersNumberGTE,omitempty"`
	MinPlayersNumberLT     *int  `json:"minPlayersNumberLT,omitempty"`
	MinPlayersNumberLTE    *int  `json:"minPlayersNumberLTE,omitempty"`
	MinPlayersNumberIsNil  bool  `json:"minPlayersNumberIsNil,omitempty"`
	MinPlayersNumberNotNil bool  `json:"minPlayersNumberNotNil,omitempty"`

	// "prerequisite" field predicates.
	Prerequisite             *string  `json:"prerequisite,omitempty"`
	PrerequisiteNEQ          *string  `json:"prerequisiteNEQ,omitempty"`
	PrerequisiteIn           []string `json:"prerequisiteIn,omitempty"`
	PrerequisiteNotIn        []string `json:"prerequisiteNotIn,omitempty"`
	PrerequisiteGT           *string  `json:"prerequisiteGT,omitempty"`
	PrerequisiteGTE          *string  `json:"prerequisiteGTE,omitempty"`
	PrerequisiteLT           *string  `json:"prerequisiteLT,omitempty"`
	PrerequisiteLTE          *string  `json:"prerequisiteLTE,omitempty"`
	PrerequisiteContains     *string  `json:"prerequisiteContains,omitempty"`
	PrerequisiteHasPrefix    *string  `json:"prerequisiteHasPrefix,omitempty"`
	PrerequisiteHasSuffix    *string  `json:"prerequisiteHasSuffix,omitempty"`
	PrerequisiteIsNil        bool     `json:"prerequisiteIsNil,omitempty"`
	PrerequisiteNotNil       bool     `json:"prerequisiteNotNil,omitempty"`
	PrerequisiteEqualFold    *string  `json:"prerequisiteEqualFold,omitempty"`
	PrerequisiteContainsFold *string  `json:"prerequisiteContainsFold,omitempty"`

	// "cost" field predicates.
	Cost             *string  `json:"cost,omitempty"`
	CostNEQ          *string  `json:"costNEQ,omitempty"`
	CostIn           []string `json:"costIn,omitempty"`
	CostNotIn        []string `json:"costNotIn,omitempty"`
	CostGT           *string  `json:"costGT,omitempty"`
	CostGTE          *string  `json:"costGTE,omitempty"`
	CostLT           *string  `json:"costLT,omitempty"`
	CostLTE          *string  `json:"costLTE,omitempty"`
	CostContains     *string  `json:"costContains,omitempty"`
	CostHasPrefix    *string  `json:"costHasPrefix,omitempty"`
	CostHasSuffix    *string  `json:"costHasSuffix,omitempty"`
	CostIsNil        bool     `json:"costIsNil,omitempty"`
	CostNotNil       bool     `json:"costNotNil,omitempty"`
	CostEqualFold    *string  `json:"costEqualFold,omitempty"`
	CostContainsFold *string  `json:"costContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "note" field predicates.
	Note             *string  `json:"note,omitempty"`
	NoteNEQ          *string  `json:"noteNEQ,omitempty"`
	NoteIn           []string `json:"noteIn,omitempty"`
	NoteNotIn        []string `json:"noteNotIn,omitempty"`
	NoteGT           *string  `json:"noteGT,omitempty"`
	NoteGTE          *string  `json:"noteGTE,omitempty"`
	NoteLT           *string  `json:"noteLT,omitempty"`
	NoteLTE          *string  `json:"noteLTE,omitempty"`
	NoteContains     *string  `json:"noteContains,omitempty"`
	NoteHasPrefix    *string  `json:"noteHasPrefix,omitempty"`
	NoteHasSuffix    *string  `json:"noteHasSuffix,omitempty"`
	NoteIsNil        bool     `json:"noteIsNil,omitempty"`
	NoteNotNil       bool     `json:"noteNotNil,omitempty"`
	NoteEqualFold    *string  `json:"noteEqualFold,omitempty"`
	NoteContainsFold *string  `json:"noteContainsFold,omitempty"`

	// "is_official_ja" field predicates.
	IsOfficialJa    *bool `json:"isOfficialJa,omitempty"`
	IsOfficialJaNEQ *bool `json:"isOfficialJaNEQ,omitempty"`

	// "victory_point" field predicates.
	VictoryPoint       *int  `json:"victoryPoint,omitempty"`
	VictoryPointNEQ    *int  `json:"victoryPointNEQ,omitempty"`
	VictoryPointIn     []int `json:"victoryPointIn,omitempty"`
	VictoryPointNotIn  []int `json:"victoryPointNotIn,omitempty"`
	VictoryPointGT     *int  `json:"victoryPointGT,omitempty"`
	VictoryPointGTE    *int  `json:"victoryPointGTE,omitempty"`
	VictoryPointLT     *int  `json:"victoryPointLT,omitempty"`
	VictoryPointLTE    *int  `json:"victoryPointLTE,omitempty"`
	VictoryPointIsNil  bool  `json:"victoryPointIsNil,omitempty"`
	VictoryPointNotNil bool  `json:"victoryPointNotNil,omitempty"`

	// "special_victory_point" field predicates.
	SpecialVictoryPoint             *string  `json:"specialVictoryPoint,omitempty"`
	SpecialVictoryPointNEQ          *string  `json:"specialVictoryPointNEQ,omitempty"`
	SpecialVictoryPointIn           []string `json:"specialVictoryPointIn,omitempty"`
	SpecialVictoryPointNotIn        []string `json:"specialVictoryPointNotIn,omitempty"`
	SpecialVictoryPointGT           *string  `json:"specialVictoryPointGT,omitempty"`
	SpecialVictoryPointGTE          *string  `json:"specialVictoryPointGTE,omitempty"`
	SpecialVictoryPointLT           *string  `json:"specialVictoryPointLT,omitempty"`
	SpecialVictoryPointLTE          *string  `json:"specialVictoryPointLTE,omitempty"`
	SpecialVictoryPointContains     *string  `json:"specialVictoryPointContains,omitempty"`
	SpecialVictoryPointHasPrefix    *string  `json:"specialVictoryPointHasPrefix,omitempty"`
	SpecialVictoryPointHasSuffix    *string  `json:"specialVictoryPointHasSuffix,omitempty"`
	SpecialVictoryPointIsNil        bool     `json:"specialVictoryPointIsNil,omitempty"`
	SpecialVictoryPointNotNil       bool     `json:"specialVictoryPointNotNil,omitempty"`
	SpecialVictoryPointEqualFold    *string  `json:"specialVictoryPointEqualFold,omitempty"`
	SpecialVictoryPointContainsFold *string  `json:"specialVictoryPointContainsFold,omitempty"`

	// "has_arrrow" field predicates.
	HasArrrow    *bool `json:"hasArrrow,omitempty"`
	HasArrrowNEQ *bool `json:"hasArrrowNEQ,omitempty"`

	// "has_bonus_point_icon" field predicates.
	HasBonusPointIcon    *bool `json:"hasBonusPointIcon,omitempty"`
	HasBonusPointIconNEQ *bool `json:"hasBonusPointIconNEQ,omitempty"`

	// "has_negative_bonus_point_icon" field predicates.
	HasNegativeBonusPointIcon    *bool `json:"hasNegativeBonusPointIcon,omitempty"`
	HasNegativeBonusPointIconNEQ *bool `json:"hasNegativeBonusPointIconNEQ,omitempty"`

	// "has_pan_icon" field predicates.
	HasPanIcon    *bool `json:"hasPanIcon,omitempty"`
	HasPanIconNEQ *bool `json:"hasPanIconNEQ,omitempty"`

	// "has_bread_icon" field predicates.
	HasBreadIcon    *bool `json:"hasBreadIcon,omitempty"`
	HasBreadIconNEQ *bool `json:"hasBreadIconNEQ,omitempty"`

	// "has_farm_planner_icon" field predicates.
	HasFarmPlannerIcon    *bool `json:"hasFarmPlannerIcon,omitempty"`
	HasFarmPlannerIconNEQ *bool `json:"hasFarmPlannerIconNEQ,omitempty"`

	// "has_actions_booster_icon" field predicates.
	HasActionsBoosterIcon    *bool `json:"hasActionsBoosterIcon,omitempty"`
	HasActionsBoosterIconNEQ *bool `json:"hasActionsBoosterIconNEQ,omitempty"`

	// "has_points_provider_icon" field predicates.
	HasPointsProviderIcon    *bool `json:"hasPointsProviderIcon,omitempty"`
	HasPointsProviderIconNEQ *bool `json:"hasPointsProviderIconNEQ,omitempty"`

	// "has_goods_provider_icon" field predicates.
	HasGoodsProviderIcon    *bool `json:"hasGoodsProviderIcon,omitempty"`
	HasGoodsProviderIconNEQ *bool `json:"hasGoodsProviderIconNEQ,omitempty"`

	// "has_food_provider_icon" field predicates.
	HasFoodProviderIcon    *bool `json:"hasFoodProviderIcon,omitempty"`
	HasFoodProviderIconNEQ *bool `json:"hasFoodProviderIconNEQ,omitempty"`

	// "has_crop_provider_icon" field predicates.
	HasCropProviderIcon    *bool `json:"hasCropProviderIcon,omitempty"`
	HasCropProviderIconNEQ *bool `json:"hasCropProviderIconNEQ,omitempty"`

	// "has_building_resource_provider_icon" field predicates.
	HasBuildingResourceProviderIcon    *bool `json:"hasBuildingResourceProviderIcon,omitempty"`
	HasBuildingResourceProviderIconNEQ *bool `json:"hasBuildingResourceProviderIconNEQ,omitempty"`

	// "has_livestock_provider_icon" field predicates.
	HasLivestockProviderIcon    *bool `json:"hasLivestockProviderIcon,omitempty"`
	HasLivestockProviderIconNEQ *bool `json:"hasLivestockProviderIconNEQ,omitempty"`

	// "has_cut_peat_icon" field predicates.
	HasCutPeatIcon    *bool `json:"hasCutPeatIcon,omitempty"`
	HasCutPeatIconNEQ *bool `json:"hasCutPeatIconNEQ,omitempty"`

	// "has_fell_trees_icon" field predicates.
	HasFellTreesIcon    *bool `json:"hasFellTreesIcon,omitempty"`
	HasFellTreesIconNEQ *bool `json:"hasFellTreesIconNEQ,omitempty"`

	// "has_slash_and_burn_icon" field predicates.
	HasSlashAndBurnIcon    *bool `json:"hasSlashAndBurnIcon,omitempty"`
	HasSlashAndBurnIconNEQ *bool `json:"hasSlashAndBurnIconNEQ,omitempty"`

	// "has_hiring_fare_icon" field predicates.
	HasHiringFareIcon    *bool `json:"hasHiringFareIcon,omitempty"`
	HasHiringFareIconNEQ *bool `json:"hasHiringFareIconNEQ,omitempty"`

	// "revision" edge predicates.
	HasRevision     *bool                 `json:"hasRevision,omitempty"`
	HasRevisionWith []*RevisionWhereInput `json:"hasRevisionWith,omitempty"`

	// "products" edge predicates.
	HasProducts     *bool                `json:"hasProducts,omitempty"`
	HasProductsWith []*ProductWhereInput `json:"hasProductsWith,omitempty"`

	// "deck" edge predicates.
	HasDeck     *bool             `json:"hasDeck,omitempty"`
	HasDeckWith []*DeckWhereInput `json:"hasDeckWith,omitempty"`

	// "card_type" edge predicates.
	HasCardType     *bool                 `json:"hasCardType,omitempty"`
	HasCardTypeWith []*CardTypeWhereInput `json:"hasCardTypeWith,omitempty"`

	// "card_special_color" edge predicates.
	HasCardSpecialColor     *bool                         `json:"hasCardSpecialColor,omitempty"`
	HasCardSpecialColorWith []*CardSpecialColorWhereInput `json:"hasCardSpecialColorWith,omitempty"`

	// "children" edge predicates.
	HasChildren     *bool             `json:"hasChildren,omitempty"`
	HasChildrenWith []*CardWhereInput `json:"hasChildrenWith,omitempty"`

	// "ancestors" edge predicates.
	HasAncestors     *bool             `json:"hasAncestors,omitempty"`
	HasAncestorsWith []*CardWhereInput `json:"hasAncestorsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CardWhereInput) AddPredicates(predicates ...predicate.Card) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CardWhereInput filter on the CardQuery builder.
func (i *CardWhereInput) Filter(q *CardQuery) (*CardQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCardWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCardWhereInput is returned in case the CardWhereInput is empty.
var ErrEmptyCardWhereInput = errors.New("ent: empty predicate CardWhereInput")

// P returns a predicate for filtering cards.
// An error is returned if the input is empty or invalid.
func (i *CardWhereInput) P() (predicate.Card, error) {
	var predicates []predicate.Card
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, card.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Card, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, card.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Card, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, card.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, card.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, card.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, card.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, card.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, card.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, card.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, card.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, card.IDLTE(*i.IDLTE))
	}
	if i.LiteralID != nil {
		predicates = append(predicates, card.LiteralIDEQ(*i.LiteralID))
	}
	if i.LiteralIDNEQ != nil {
		predicates = append(predicates, card.LiteralIDNEQ(*i.LiteralIDNEQ))
	}
	if len(i.LiteralIDIn) > 0 {
		predicates = append(predicates, card.LiteralIDIn(i.LiteralIDIn...))
	}
	if len(i.LiteralIDNotIn) > 0 {
		predicates = append(predicates, card.LiteralIDNotIn(i.LiteralIDNotIn...))
	}
	if i.LiteralIDGT != nil {
		predicates = append(predicates, card.LiteralIDGT(*i.LiteralIDGT))
	}
	if i.LiteralIDGTE != nil {
		predicates = append(predicates, card.LiteralIDGTE(*i.LiteralIDGTE))
	}
	if i.LiteralIDLT != nil {
		predicates = append(predicates, card.LiteralIDLT(*i.LiteralIDLT))
	}
	if i.LiteralIDLTE != nil {
		predicates = append(predicates, card.LiteralIDLTE(*i.LiteralIDLTE))
	}
	if i.LiteralIDContains != nil {
		predicates = append(predicates, card.LiteralIDContains(*i.LiteralIDContains))
	}
	if i.LiteralIDHasPrefix != nil {
		predicates = append(predicates, card.LiteralIDHasPrefix(*i.LiteralIDHasPrefix))
	}
	if i.LiteralIDHasSuffix != nil {
		predicates = append(predicates, card.LiteralIDHasSuffix(*i.LiteralIDHasSuffix))
	}
	if i.LiteralIDEqualFold != nil {
		predicates = append(predicates, card.LiteralIDEqualFold(*i.LiteralIDEqualFold))
	}
	if i.LiteralIDContainsFold != nil {
		predicates = append(predicates, card.LiteralIDContainsFold(*i.LiteralIDContainsFold))
	}
	if i.RevisionID != nil {
		predicates = append(predicates, card.RevisionIDEQ(*i.RevisionID))
	}
	if i.RevisionIDNEQ != nil {
		predicates = append(predicates, card.RevisionIDNEQ(*i.RevisionIDNEQ))
	}
	if len(i.RevisionIDIn) > 0 {
		predicates = append(predicates, card.RevisionIDIn(i.RevisionIDIn...))
	}
	if len(i.RevisionIDNotIn) > 0 {
		predicates = append(predicates, card.RevisionIDNotIn(i.RevisionIDNotIn...))
	}
	if i.PrintedID != nil {
		predicates = append(predicates, card.PrintedIDEQ(*i.PrintedID))
	}
	if i.PrintedIDNEQ != nil {
		predicates = append(predicates, card.PrintedIDNEQ(*i.PrintedIDNEQ))
	}
	if len(i.PrintedIDIn) > 0 {
		predicates = append(predicates, card.PrintedIDIn(i.PrintedIDIn...))
	}
	if len(i.PrintedIDNotIn) > 0 {
		predicates = append(predicates, card.PrintedIDNotIn(i.PrintedIDNotIn...))
	}
	if i.PrintedIDGT != nil {
		predicates = append(predicates, card.PrintedIDGT(*i.PrintedIDGT))
	}
	if i.PrintedIDGTE != nil {
		predicates = append(predicates, card.PrintedIDGTE(*i.PrintedIDGTE))
	}
	if i.PrintedIDLT != nil {
		predicates = append(predicates, card.PrintedIDLT(*i.PrintedIDLT))
	}
	if i.PrintedIDLTE != nil {
		predicates = append(predicates, card.PrintedIDLTE(*i.PrintedIDLTE))
	}
	if i.PrintedIDContains != nil {
		predicates = append(predicates, card.PrintedIDContains(*i.PrintedIDContains))
	}
	if i.PrintedIDHasPrefix != nil {
		predicates = append(predicates, card.PrintedIDHasPrefix(*i.PrintedIDHasPrefix))
	}
	if i.PrintedIDHasSuffix != nil {
		predicates = append(predicates, card.PrintedIDHasSuffix(*i.PrintedIDHasSuffix))
	}
	if i.PrintedIDIsNil {
		predicates = append(predicates, card.PrintedIDIsNil())
	}
	if i.PrintedIDNotNil {
		predicates = append(predicates, card.PrintedIDNotNil())
	}
	if i.PrintedIDEqualFold != nil {
		predicates = append(predicates, card.PrintedIDEqualFold(*i.PrintedIDEqualFold))
	}
	if i.PrintedIDContainsFold != nil {
		predicates = append(predicates, card.PrintedIDContainsFold(*i.PrintedIDContainsFold))
	}
	if i.PlayAgricolaCardID != nil {
		predicates = append(predicates, card.PlayAgricolaCardIDEQ(*i.PlayAgricolaCardID))
	}
	if i.PlayAgricolaCardIDNEQ != nil {
		predicates = append(predicates, card.PlayAgricolaCardIDNEQ(*i.PlayAgricolaCardIDNEQ))
	}
	if len(i.PlayAgricolaCardIDIn) > 0 {
		predicates = append(predicates, card.PlayAgricolaCardIDIn(i.PlayAgricolaCardIDIn...))
	}
	if len(i.PlayAgricolaCardIDNotIn) > 0 {
		predicates = append(predicates, card.PlayAgricolaCardIDNotIn(i.PlayAgricolaCardIDNotIn...))
	}
	if i.PlayAgricolaCardIDGT != nil {
		predicates = append(predicates, card.PlayAgricolaCardIDGT(*i.PlayAgricolaCardIDGT))
	}
	if i.PlayAgricolaCardIDGTE != nil {
		predicates = append(predicates, card.PlayAgricolaCardIDGTE(*i.PlayAgricolaCardIDGTE))
	}
	if i.PlayAgricolaCardIDLT != nil {
		predicates = append(predicates, card.PlayAgricolaCardIDLT(*i.PlayAgricolaCardIDLT))
	}
	if i.PlayAgricolaCardIDLTE != nil {
		predicates = append(predicates, card.PlayAgricolaCardIDLTE(*i.PlayAgricolaCardIDLTE))
	}
	if i.PlayAgricolaCardIDContains != nil {
		predicates = append(predicates, card.PlayAgricolaCardIDContains(*i.PlayAgricolaCardIDContains))
	}
	if i.PlayAgricolaCardIDHasPrefix != nil {
		predicates = append(predicates, card.PlayAgricolaCardIDHasPrefix(*i.PlayAgricolaCardIDHasPrefix))
	}
	if i.PlayAgricolaCardIDHasSuffix != nil {
		predicates = append(predicates, card.PlayAgricolaCardIDHasSuffix(*i.PlayAgricolaCardIDHasSuffix))
	}
	if i.PlayAgricolaCardIDIsNil {
		predicates = append(predicates, card.PlayAgricolaCardIDIsNil())
	}
	if i.PlayAgricolaCardIDNotNil {
		predicates = append(predicates, card.PlayAgricolaCardIDNotNil())
	}
	if i.PlayAgricolaCardIDEqualFold != nil {
		predicates = append(predicates, card.PlayAgricolaCardIDEqualFold(*i.PlayAgricolaCardIDEqualFold))
	}
	if i.PlayAgricolaCardIDContainsFold != nil {
		predicates = append(predicates, card.PlayAgricolaCardIDContainsFold(*i.PlayAgricolaCardIDContainsFold))
	}
	if i.DeckID != nil {
		predicates = append(predicates, card.DeckIDEQ(*i.DeckID))
	}
	if i.DeckIDNEQ != nil {
		predicates = append(predicates, card.DeckIDNEQ(*i.DeckIDNEQ))
	}
	if len(i.DeckIDIn) > 0 {
		predicates = append(predicates, card.DeckIDIn(i.DeckIDIn...))
	}
	if len(i.DeckIDNotIn) > 0 {
		predicates = append(predicates, card.DeckIDNotIn(i.DeckIDNotIn...))
	}
	if i.DeckIDIsNil {
		predicates = append(predicates, card.DeckIDIsNil())
	}
	if i.DeckIDNotNil {
		predicates = append(predicates, card.DeckIDNotNil())
	}
	if i.CardTypeID != nil {
		predicates = append(predicates, card.CardTypeIDEQ(*i.CardTypeID))
	}
	if i.CardTypeIDNEQ != nil {
		predicates = append(predicates, card.CardTypeIDNEQ(*i.CardTypeIDNEQ))
	}
	if len(i.CardTypeIDIn) > 0 {
		predicates = append(predicates, card.CardTypeIDIn(i.CardTypeIDIn...))
	}
	if len(i.CardTypeIDNotIn) > 0 {
		predicates = append(predicates, card.CardTypeIDNotIn(i.CardTypeIDNotIn...))
	}
	if i.CardSpecialColorID != nil {
		predicates = append(predicates, card.CardSpecialColorIDEQ(*i.CardSpecialColorID))
	}
	if i.CardSpecialColorIDNEQ != nil {
		predicates = append(predicates, card.CardSpecialColorIDNEQ(*i.CardSpecialColorIDNEQ))
	}
	if len(i.CardSpecialColorIDIn) > 0 {
		predicates = append(predicates, card.CardSpecialColorIDIn(i.CardSpecialColorIDIn...))
	}
	if len(i.CardSpecialColorIDNotIn) > 0 {
		predicates = append(predicates, card.CardSpecialColorIDNotIn(i.CardSpecialColorIDNotIn...))
	}
	if i.CardSpecialColorIDIsNil {
		predicates = append(predicates, card.CardSpecialColorIDIsNil())
	}
	if i.CardSpecialColorIDNotNil {
		predicates = append(predicates, card.CardSpecialColorIDNotNil())
	}
	if i.NameJa != nil {
		predicates = append(predicates, card.NameJaEQ(*i.NameJa))
	}
	if i.NameJaNEQ != nil {
		predicates = append(predicates, card.NameJaNEQ(*i.NameJaNEQ))
	}
	if len(i.NameJaIn) > 0 {
		predicates = append(predicates, card.NameJaIn(i.NameJaIn...))
	}
	if len(i.NameJaNotIn) > 0 {
		predicates = append(predicates, card.NameJaNotIn(i.NameJaNotIn...))
	}
	if i.NameJaGT != nil {
		predicates = append(predicates, card.NameJaGT(*i.NameJaGT))
	}
	if i.NameJaGTE != nil {
		predicates = append(predicates, card.NameJaGTE(*i.NameJaGTE))
	}
	if i.NameJaLT != nil {
		predicates = append(predicates, card.NameJaLT(*i.NameJaLT))
	}
	if i.NameJaLTE != nil {
		predicates = append(predicates, card.NameJaLTE(*i.NameJaLTE))
	}
	if i.NameJaContains != nil {
		predicates = append(predicates, card.NameJaContains(*i.NameJaContains))
	}
	if i.NameJaHasPrefix != nil {
		predicates = append(predicates, card.NameJaHasPrefix(*i.NameJaHasPrefix))
	}
	if i.NameJaHasSuffix != nil {
		predicates = append(predicates, card.NameJaHasSuffix(*i.NameJaHasSuffix))
	}
	if i.NameJaIsNil {
		predicates = append(predicates, card.NameJaIsNil())
	}
	if i.NameJaNotNil {
		predicates = append(predicates, card.NameJaNotNil())
	}
	if i.NameJaEqualFold != nil {
		predicates = append(predicates, card.NameJaEqualFold(*i.NameJaEqualFold))
	}
	if i.NameJaContainsFold != nil {
		predicates = append(predicates, card.NameJaContainsFold(*i.NameJaContainsFold))
	}
	if i.NameEn != nil {
		predicates = append(predicates, card.NameEnEQ(*i.NameEn))
	}
	if i.NameEnNEQ != nil {
		predicates = append(predicates, card.NameEnNEQ(*i.NameEnNEQ))
	}
	if len(i.NameEnIn) > 0 {
		predicates = append(predicates, card.NameEnIn(i.NameEnIn...))
	}
	if len(i.NameEnNotIn) > 0 {
		predicates = append(predicates, card.NameEnNotIn(i.NameEnNotIn...))
	}
	if i.NameEnGT != nil {
		predicates = append(predicates, card.NameEnGT(*i.NameEnGT))
	}
	if i.NameEnGTE != nil {
		predicates = append(predicates, card.NameEnGTE(*i.NameEnGTE))
	}
	if i.NameEnLT != nil {
		predicates = append(predicates, card.NameEnLT(*i.NameEnLT))
	}
	if i.NameEnLTE != nil {
		predicates = append(predicates, card.NameEnLTE(*i.NameEnLTE))
	}
	if i.NameEnContains != nil {
		predicates = append(predicates, card.NameEnContains(*i.NameEnContains))
	}
	if i.NameEnHasPrefix != nil {
		predicates = append(predicates, card.NameEnHasPrefix(*i.NameEnHasPrefix))
	}
	if i.NameEnHasSuffix != nil {
		predicates = append(predicates, card.NameEnHasSuffix(*i.NameEnHasSuffix))
	}
	if i.NameEnIsNil {
		predicates = append(predicates, card.NameEnIsNil())
	}
	if i.NameEnNotNil {
		predicates = append(predicates, card.NameEnNotNil())
	}
	if i.NameEnEqualFold != nil {
		predicates = append(predicates, card.NameEnEqualFold(*i.NameEnEqualFold))
	}
	if i.NameEnContainsFold != nil {
		predicates = append(predicates, card.NameEnContainsFold(*i.NameEnContainsFold))
	}
	if i.MinPlayersNumber != nil {
		predicates = append(predicates, card.MinPlayersNumberEQ(*i.MinPlayersNumber))
	}
	if i.MinPlayersNumberNEQ != nil {
		predicates = append(predicates, card.MinPlayersNumberNEQ(*i.MinPlayersNumberNEQ))
	}
	if len(i.MinPlayersNumberIn) > 0 {
		predicates = append(predicates, card.MinPlayersNumberIn(i.MinPlayersNumberIn...))
	}
	if len(i.MinPlayersNumberNotIn) > 0 {
		predicates = append(predicates, card.MinPlayersNumberNotIn(i.MinPlayersNumberNotIn...))
	}
	if i.MinPlayersNumberGT != nil {
		predicates = append(predicates, card.MinPlayersNumberGT(*i.MinPlayersNumberGT))
	}
	if i.MinPlayersNumberGTE != nil {
		predicates = append(predicates, card.MinPlayersNumberGTE(*i.MinPlayersNumberGTE))
	}
	if i.MinPlayersNumberLT != nil {
		predicates = append(predicates, card.MinPlayersNumberLT(*i.MinPlayersNumberLT))
	}
	if i.MinPlayersNumberLTE != nil {
		predicates = append(predicates, card.MinPlayersNumberLTE(*i.MinPlayersNumberLTE))
	}
	if i.MinPlayersNumberIsNil {
		predicates = append(predicates, card.MinPlayersNumberIsNil())
	}
	if i.MinPlayersNumberNotNil {
		predicates = append(predicates, card.MinPlayersNumberNotNil())
	}
	if i.Prerequisite != nil {
		predicates = append(predicates, card.PrerequisiteEQ(*i.Prerequisite))
	}
	if i.PrerequisiteNEQ != nil {
		predicates = append(predicates, card.PrerequisiteNEQ(*i.PrerequisiteNEQ))
	}
	if len(i.PrerequisiteIn) > 0 {
		predicates = append(predicates, card.PrerequisiteIn(i.PrerequisiteIn...))
	}
	if len(i.PrerequisiteNotIn) > 0 {
		predicates = append(predicates, card.PrerequisiteNotIn(i.PrerequisiteNotIn...))
	}
	if i.PrerequisiteGT != nil {
		predicates = append(predicates, card.PrerequisiteGT(*i.PrerequisiteGT))
	}
	if i.PrerequisiteGTE != nil {
		predicates = append(predicates, card.PrerequisiteGTE(*i.PrerequisiteGTE))
	}
	if i.PrerequisiteLT != nil {
		predicates = append(predicates, card.PrerequisiteLT(*i.PrerequisiteLT))
	}
	if i.PrerequisiteLTE != nil {
		predicates = append(predicates, card.PrerequisiteLTE(*i.PrerequisiteLTE))
	}
	if i.PrerequisiteContains != nil {
		predicates = append(predicates, card.PrerequisiteContains(*i.PrerequisiteContains))
	}
	if i.PrerequisiteHasPrefix != nil {
		predicates = append(predicates, card.PrerequisiteHasPrefix(*i.PrerequisiteHasPrefix))
	}
	if i.PrerequisiteHasSuffix != nil {
		predicates = append(predicates, card.PrerequisiteHasSuffix(*i.PrerequisiteHasSuffix))
	}
	if i.PrerequisiteIsNil {
		predicates = append(predicates, card.PrerequisiteIsNil())
	}
	if i.PrerequisiteNotNil {
		predicates = append(predicates, card.PrerequisiteNotNil())
	}
	if i.PrerequisiteEqualFold != nil {
		predicates = append(predicates, card.PrerequisiteEqualFold(*i.PrerequisiteEqualFold))
	}
	if i.PrerequisiteContainsFold != nil {
		predicates = append(predicates, card.PrerequisiteContainsFold(*i.PrerequisiteContainsFold))
	}
	if i.Cost != nil {
		predicates = append(predicates, card.CostEQ(*i.Cost))
	}
	if i.CostNEQ != nil {
		predicates = append(predicates, card.CostNEQ(*i.CostNEQ))
	}
	if len(i.CostIn) > 0 {
		predicates = append(predicates, card.CostIn(i.CostIn...))
	}
	if len(i.CostNotIn) > 0 {
		predicates = append(predicates, card.CostNotIn(i.CostNotIn...))
	}
	if i.CostGT != nil {
		predicates = append(predicates, card.CostGT(*i.CostGT))
	}
	if i.CostGTE != nil {
		predicates = append(predicates, card.CostGTE(*i.CostGTE))
	}
	if i.CostLT != nil {
		predicates = append(predicates, card.CostLT(*i.CostLT))
	}
	if i.CostLTE != nil {
		predicates = append(predicates, card.CostLTE(*i.CostLTE))
	}
	if i.CostContains != nil {
		predicates = append(predicates, card.CostContains(*i.CostContains))
	}
	if i.CostHasPrefix != nil {
		predicates = append(predicates, card.CostHasPrefix(*i.CostHasPrefix))
	}
	if i.CostHasSuffix != nil {
		predicates = append(predicates, card.CostHasSuffix(*i.CostHasSuffix))
	}
	if i.CostIsNil {
		predicates = append(predicates, card.CostIsNil())
	}
	if i.CostNotNil {
		predicates = append(predicates, card.CostNotNil())
	}
	if i.CostEqualFold != nil {
		predicates = append(predicates, card.CostEqualFold(*i.CostEqualFold))
	}
	if i.CostContainsFold != nil {
		predicates = append(predicates, card.CostContainsFold(*i.CostContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, card.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, card.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, card.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, card.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, card.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, card.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, card.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, card.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, card.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, card.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, card.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, card.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, card.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, card.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, card.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Note != nil {
		predicates = append(predicates, card.NoteEQ(*i.Note))
	}
	if i.NoteNEQ != nil {
		predicates = append(predicates, card.NoteNEQ(*i.NoteNEQ))
	}
	if len(i.NoteIn) > 0 {
		predicates = append(predicates, card.NoteIn(i.NoteIn...))
	}
	if len(i.NoteNotIn) > 0 {
		predicates = append(predicates, card.NoteNotIn(i.NoteNotIn...))
	}
	if i.NoteGT != nil {
		predicates = append(predicates, card.NoteGT(*i.NoteGT))
	}
	if i.NoteGTE != nil {
		predicates = append(predicates, card.NoteGTE(*i.NoteGTE))
	}
	if i.NoteLT != nil {
		predicates = append(predicates, card.NoteLT(*i.NoteLT))
	}
	if i.NoteLTE != nil {
		predicates = append(predicates, card.NoteLTE(*i.NoteLTE))
	}
	if i.NoteContains != nil {
		predicates = append(predicates, card.NoteContains(*i.NoteContains))
	}
	if i.NoteHasPrefix != nil {
		predicates = append(predicates, card.NoteHasPrefix(*i.NoteHasPrefix))
	}
	if i.NoteHasSuffix != nil {
		predicates = append(predicates, card.NoteHasSuffix(*i.NoteHasSuffix))
	}
	if i.NoteIsNil {
		predicates = append(predicates, card.NoteIsNil())
	}
	if i.NoteNotNil {
		predicates = append(predicates, card.NoteNotNil())
	}
	if i.NoteEqualFold != nil {
		predicates = append(predicates, card.NoteEqualFold(*i.NoteEqualFold))
	}
	if i.NoteContainsFold != nil {
		predicates = append(predicates, card.NoteContainsFold(*i.NoteContainsFold))
	}
	if i.IsOfficialJa != nil {
		predicates = append(predicates, card.IsOfficialJaEQ(*i.IsOfficialJa))
	}
	if i.IsOfficialJaNEQ != nil {
		predicates = append(predicates, card.IsOfficialJaNEQ(*i.IsOfficialJaNEQ))
	}
	if i.VictoryPoint != nil {
		predicates = append(predicates, card.VictoryPointEQ(*i.VictoryPoint))
	}
	if i.VictoryPointNEQ != nil {
		predicates = append(predicates, card.VictoryPointNEQ(*i.VictoryPointNEQ))
	}
	if len(i.VictoryPointIn) > 0 {
		predicates = append(predicates, card.VictoryPointIn(i.VictoryPointIn...))
	}
	if len(i.VictoryPointNotIn) > 0 {
		predicates = append(predicates, card.VictoryPointNotIn(i.VictoryPointNotIn...))
	}
	if i.VictoryPointGT != nil {
		predicates = append(predicates, card.VictoryPointGT(*i.VictoryPointGT))
	}
	if i.VictoryPointGTE != nil {
		predicates = append(predicates, card.VictoryPointGTE(*i.VictoryPointGTE))
	}
	if i.VictoryPointLT != nil {
		predicates = append(predicates, card.VictoryPointLT(*i.VictoryPointLT))
	}
	if i.VictoryPointLTE != nil {
		predicates = append(predicates, card.VictoryPointLTE(*i.VictoryPointLTE))
	}
	if i.VictoryPointIsNil {
		predicates = append(predicates, card.VictoryPointIsNil())
	}
	if i.VictoryPointNotNil {
		predicates = append(predicates, card.VictoryPointNotNil())
	}
	if i.SpecialVictoryPoint != nil {
		predicates = append(predicates, card.SpecialVictoryPointEQ(*i.SpecialVictoryPoint))
	}
	if i.SpecialVictoryPointNEQ != nil {
		predicates = append(predicates, card.SpecialVictoryPointNEQ(*i.SpecialVictoryPointNEQ))
	}
	if len(i.SpecialVictoryPointIn) > 0 {
		predicates = append(predicates, card.SpecialVictoryPointIn(i.SpecialVictoryPointIn...))
	}
	if len(i.SpecialVictoryPointNotIn) > 0 {
		predicates = append(predicates, card.SpecialVictoryPointNotIn(i.SpecialVictoryPointNotIn...))
	}
	if i.SpecialVictoryPointGT != nil {
		predicates = append(predicates, card.SpecialVictoryPointGT(*i.SpecialVictoryPointGT))
	}
	if i.SpecialVictoryPointGTE != nil {
		predicates = append(predicates, card.SpecialVictoryPointGTE(*i.SpecialVictoryPointGTE))
	}
	if i.SpecialVictoryPointLT != nil {
		predicates = append(predicates, card.SpecialVictoryPointLT(*i.SpecialVictoryPointLT))
	}
	if i.SpecialVictoryPointLTE != nil {
		predicates = append(predicates, card.SpecialVictoryPointLTE(*i.SpecialVictoryPointLTE))
	}
	if i.SpecialVictoryPointContains != nil {
		predicates = append(predicates, card.SpecialVictoryPointContains(*i.SpecialVictoryPointContains))
	}
	if i.SpecialVictoryPointHasPrefix != nil {
		predicates = append(predicates, card.SpecialVictoryPointHasPrefix(*i.SpecialVictoryPointHasPrefix))
	}
	if i.SpecialVictoryPointHasSuffix != nil {
		predicates = append(predicates, card.SpecialVictoryPointHasSuffix(*i.SpecialVictoryPointHasSuffix))
	}
	if i.SpecialVictoryPointIsNil {
		predicates = append(predicates, card.SpecialVictoryPointIsNil())
	}
	if i.SpecialVictoryPointNotNil {
		predicates = append(predicates, card.SpecialVictoryPointNotNil())
	}
	if i.SpecialVictoryPointEqualFold != nil {
		predicates = append(predicates, card.SpecialVictoryPointEqualFold(*i.SpecialVictoryPointEqualFold))
	}
	if i.SpecialVictoryPointContainsFold != nil {
		predicates = append(predicates, card.SpecialVictoryPointContainsFold(*i.SpecialVictoryPointContainsFold))
	}
	if i.HasArrrow != nil {
		predicates = append(predicates, card.HasArrrowEQ(*i.HasArrrow))
	}
	if i.HasArrrowNEQ != nil {
		predicates = append(predicates, card.HasArrrowNEQ(*i.HasArrrowNEQ))
	}
	if i.HasBonusPointIcon != nil {
		predicates = append(predicates, card.HasBonusPointIconEQ(*i.HasBonusPointIcon))
	}
	if i.HasBonusPointIconNEQ != nil {
		predicates = append(predicates, card.HasBonusPointIconNEQ(*i.HasBonusPointIconNEQ))
	}
	if i.HasNegativeBonusPointIcon != nil {
		predicates = append(predicates, card.HasNegativeBonusPointIconEQ(*i.HasNegativeBonusPointIcon))
	}
	if i.HasNegativeBonusPointIconNEQ != nil {
		predicates = append(predicates, card.HasNegativeBonusPointIconNEQ(*i.HasNegativeBonusPointIconNEQ))
	}
	if i.HasPanIcon != nil {
		predicates = append(predicates, card.HasPanIconEQ(*i.HasPanIcon))
	}
	if i.HasPanIconNEQ != nil {
		predicates = append(predicates, card.HasPanIconNEQ(*i.HasPanIconNEQ))
	}
	if i.HasBreadIcon != nil {
		predicates = append(predicates, card.HasBreadIconEQ(*i.HasBreadIcon))
	}
	if i.HasBreadIconNEQ != nil {
		predicates = append(predicates, card.HasBreadIconNEQ(*i.HasBreadIconNEQ))
	}
	if i.HasFarmPlannerIcon != nil {
		predicates = append(predicates, card.HasFarmPlannerIconEQ(*i.HasFarmPlannerIcon))
	}
	if i.HasFarmPlannerIconNEQ != nil {
		predicates = append(predicates, card.HasFarmPlannerIconNEQ(*i.HasFarmPlannerIconNEQ))
	}
	if i.HasActionsBoosterIcon != nil {
		predicates = append(predicates, card.HasActionsBoosterIconEQ(*i.HasActionsBoosterIcon))
	}
	if i.HasActionsBoosterIconNEQ != nil {
		predicates = append(predicates, card.HasActionsBoosterIconNEQ(*i.HasActionsBoosterIconNEQ))
	}
	if i.HasPointsProviderIcon != nil {
		predicates = append(predicates, card.HasPointsProviderIconEQ(*i.HasPointsProviderIcon))
	}
	if i.HasPointsProviderIconNEQ != nil {
		predicates = append(predicates, card.HasPointsProviderIconNEQ(*i.HasPointsProviderIconNEQ))
	}
	if i.HasGoodsProviderIcon != nil {
		predicates = append(predicates, card.HasGoodsProviderIconEQ(*i.HasGoodsProviderIcon))
	}
	if i.HasGoodsProviderIconNEQ != nil {
		predicates = append(predicates, card.HasGoodsProviderIconNEQ(*i.HasGoodsProviderIconNEQ))
	}
	if i.HasFoodProviderIcon != nil {
		predicates = append(predicates, card.HasFoodProviderIconEQ(*i.HasFoodProviderIcon))
	}
	if i.HasFoodProviderIconNEQ != nil {
		predicates = append(predicates, card.HasFoodProviderIconNEQ(*i.HasFoodProviderIconNEQ))
	}
	if i.HasCropProviderIcon != nil {
		predicates = append(predicates, card.HasCropProviderIconEQ(*i.HasCropProviderIcon))
	}
	if i.HasCropProviderIconNEQ != nil {
		predicates = append(predicates, card.HasCropProviderIconNEQ(*i.HasCropProviderIconNEQ))
	}
	if i.HasBuildingResourceProviderIcon != nil {
		predicates = append(predicates, card.HasBuildingResourceProviderIconEQ(*i.HasBuildingResourceProviderIcon))
	}
	if i.HasBuildingResourceProviderIconNEQ != nil {
		predicates = append(predicates, card.HasBuildingResourceProviderIconNEQ(*i.HasBuildingResourceProviderIconNEQ))
	}
	if i.HasLivestockProviderIcon != nil {
		predicates = append(predicates, card.HasLivestockProviderIconEQ(*i.HasLivestockProviderIcon))
	}
	if i.HasLivestockProviderIconNEQ != nil {
		predicates = append(predicates, card.HasLivestockProviderIconNEQ(*i.HasLivestockProviderIconNEQ))
	}
	if i.HasCutPeatIcon != nil {
		predicates = append(predicates, card.HasCutPeatIconEQ(*i.HasCutPeatIcon))
	}
	if i.HasCutPeatIconNEQ != nil {
		predicates = append(predicates, card.HasCutPeatIconNEQ(*i.HasCutPeatIconNEQ))
	}
	if i.HasFellTreesIcon != nil {
		predicates = append(predicates, card.HasFellTreesIconEQ(*i.HasFellTreesIcon))
	}
	if i.HasFellTreesIconNEQ != nil {
		predicates = append(predicates, card.HasFellTreesIconNEQ(*i.HasFellTreesIconNEQ))
	}
	if i.HasSlashAndBurnIcon != nil {
		predicates = append(predicates, card.HasSlashAndBurnIconEQ(*i.HasSlashAndBurnIcon))
	}
	if i.HasSlashAndBurnIconNEQ != nil {
		predicates = append(predicates, card.HasSlashAndBurnIconNEQ(*i.HasSlashAndBurnIconNEQ))
	}
	if i.HasHiringFareIcon != nil {
		predicates = append(predicates, card.HasHiringFareIconEQ(*i.HasHiringFareIcon))
	}
	if i.HasHiringFareIconNEQ != nil {
		predicates = append(predicates, card.HasHiringFareIconNEQ(*i.HasHiringFareIconNEQ))
	}

	if i.HasRevision != nil {
		p := card.HasRevision()
		if !*i.HasRevision {
			p = card.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRevisionWith) > 0 {
		with := make([]predicate.Revision, 0, len(i.HasRevisionWith))
		for _, w := range i.HasRevisionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRevisionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, card.HasRevisionWith(with...))
	}
	if i.HasProducts != nil {
		p := card.HasProducts()
		if !*i.HasProducts {
			p = card.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductsWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductsWith))
		for _, w := range i.HasProductsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, card.HasProductsWith(with...))
	}
	if i.HasDeck != nil {
		p := card.HasDeck()
		if !*i.HasDeck {
			p = card.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeckWith) > 0 {
		with := make([]predicate.Deck, 0, len(i.HasDeckWith))
		for _, w := range i.HasDeckWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeckWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, card.HasDeckWith(with...))
	}
	if i.HasCardType != nil {
		p := card.HasCardType()
		if !*i.HasCardType {
			p = card.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCardTypeWith) > 0 {
		with := make([]predicate.CardType, 0, len(i.HasCardTypeWith))
		for _, w := range i.HasCardTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCardTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, card.HasCardTypeWith(with...))
	}
	if i.HasCardSpecialColor != nil {
		p := card.HasCardSpecialColor()
		if !*i.HasCardSpecialColor {
			p = card.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCardSpecialColorWith) > 0 {
		with := make([]predicate.CardSpecialColor, 0, len(i.HasCardSpecialColorWith))
		for _, w := range i.HasCardSpecialColorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCardSpecialColorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, card.HasCardSpecialColorWith(with...))
	}
	if i.HasChildren != nil {
		p := card.HasChildren()
		if !*i.HasChildren {
			p = card.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChildrenWith) > 0 {
		with := make([]predicate.Card, 0, len(i.HasChildrenWith))
		for _, w := range i.HasChildrenWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChildrenWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, card.HasChildrenWith(with...))
	}
	if i.HasAncestors != nil {
		p := card.HasAncestors()
		if !*i.HasAncestors {
			p = card.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAncestorsWith) > 0 {
		with := make([]predicate.Card, 0, len(i.HasAncestorsWith))
		for _, w := range i.HasAncestorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAncestorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, card.HasAncestorsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCardWhereInput
	case 1:
		return predicates[0], nil
	default:
		return card.And(predicates...), nil
	}
}

// CardSpecialColorWhereInput represents a where input for filtering CardSpecialColor queries.
type CardSpecialColorWhereInput struct {
	Predicates []predicate.CardSpecialColor  `json:"-"`
	Not        *CardSpecialColorWhereInput   `json:"not,omitempty"`
	Or         []*CardSpecialColorWhereInput `json:"or,omitempty"`
	And        []*CardSpecialColorWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "name_ja" field predicates.
	NameJa             *string  `json:"nameJa,omitempty"`
	NameJaNEQ          *string  `json:"nameJaNEQ,omitempty"`
	NameJaIn           []string `json:"nameJaIn,omitempty"`
	NameJaNotIn        []string `json:"nameJaNotIn,omitempty"`
	NameJaGT           *string  `json:"nameJaGT,omitempty"`
	NameJaGTE          *string  `json:"nameJaGTE,omitempty"`
	NameJaLT           *string  `json:"nameJaLT,omitempty"`
	NameJaLTE          *string  `json:"nameJaLTE,omitempty"`
	NameJaContains     *string  `json:"nameJaContains,omitempty"`
	NameJaHasPrefix    *string  `json:"nameJaHasPrefix,omitempty"`
	NameJaHasSuffix    *string  `json:"nameJaHasSuffix,omitempty"`
	NameJaIsNil        bool     `json:"nameJaIsNil,omitempty"`
	NameJaNotNil       bool     `json:"nameJaNotNil,omitempty"`
	NameJaEqualFold    *string  `json:"nameJaEqualFold,omitempty"`
	NameJaContainsFold *string  `json:"nameJaContainsFold,omitempty"`

	// "name_en" field predicates.
	NameEn             *string  `json:"nameEn,omitempty"`
	NameEnNEQ          *string  `json:"nameEnNEQ,omitempty"`
	NameEnIn           []string `json:"nameEnIn,omitempty"`
	NameEnNotIn        []string `json:"nameEnNotIn,omitempty"`
	NameEnGT           *string  `json:"nameEnGT,omitempty"`
	NameEnGTE          *string  `json:"nameEnGTE,omitempty"`
	NameEnLT           *string  `json:"nameEnLT,omitempty"`
	NameEnLTE          *string  `json:"nameEnLTE,omitempty"`
	NameEnContains     *string  `json:"nameEnContains,omitempty"`
	NameEnHasPrefix    *string  `json:"nameEnHasPrefix,omitempty"`
	NameEnHasSuffix    *string  `json:"nameEnHasSuffix,omitempty"`
	NameEnIsNil        bool     `json:"nameEnIsNil,omitempty"`
	NameEnNotNil       bool     `json:"nameEnNotNil,omitempty"`
	NameEnEqualFold    *string  `json:"nameEnEqualFold,omitempty"`
	NameEnContainsFold *string  `json:"nameEnContainsFold,omitempty"`

	// "cards" edge predicates.
	HasCards     *bool             `json:"hasCards,omitempty"`
	HasCardsWith []*CardWhereInput `json:"hasCardsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CardSpecialColorWhereInput) AddPredicates(predicates ...predicate.CardSpecialColor) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CardSpecialColorWhereInput filter on the CardSpecialColorQuery builder.
func (i *CardSpecialColorWhereInput) Filter(q *CardSpecialColorQuery) (*CardSpecialColorQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCardSpecialColorWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCardSpecialColorWhereInput is returned in case the CardSpecialColorWhereInput is empty.
var ErrEmptyCardSpecialColorWhereInput = errors.New("ent: empty predicate CardSpecialColorWhereInput")

// P returns a predicate for filtering cardspecialcolors.
// An error is returned if the input is empty or invalid.
func (i *CardSpecialColorWhereInput) P() (predicate.CardSpecialColor, error) {
	var predicates []predicate.CardSpecialColor
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, cardspecialcolor.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CardSpecialColor, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, cardspecialcolor.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CardSpecialColor, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, cardspecialcolor.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, cardspecialcolor.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, cardspecialcolor.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, cardspecialcolor.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, cardspecialcolor.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, cardspecialcolor.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, cardspecialcolor.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, cardspecialcolor.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, cardspecialcolor.IDLTE(*i.IDLTE))
	}
	if i.Key != nil {
		predicates = append(predicates, cardspecialcolor.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, cardspecialcolor.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, cardspecialcolor.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, cardspecialcolor.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, cardspecialcolor.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, cardspecialcolor.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, cardspecialcolor.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, cardspecialcolor.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, cardspecialcolor.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, cardspecialcolor.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, cardspecialcolor.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, cardspecialcolor.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, cardspecialcolor.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.NameJa != nil {
		predicates = append(predicates, cardspecialcolor.NameJaEQ(*i.NameJa))
	}
	if i.NameJaNEQ != nil {
		predicates = append(predicates, cardspecialcolor.NameJaNEQ(*i.NameJaNEQ))
	}
	if len(i.NameJaIn) > 0 {
		predicates = append(predicates, cardspecialcolor.NameJaIn(i.NameJaIn...))
	}
	if len(i.NameJaNotIn) > 0 {
		predicates = append(predicates, cardspecialcolor.NameJaNotIn(i.NameJaNotIn...))
	}
	if i.NameJaGT != nil {
		predicates = append(predicates, cardspecialcolor.NameJaGT(*i.NameJaGT))
	}
	if i.NameJaGTE != nil {
		predicates = append(predicates, cardspecialcolor.NameJaGTE(*i.NameJaGTE))
	}
	if i.NameJaLT != nil {
		predicates = append(predicates, cardspecialcolor.NameJaLT(*i.NameJaLT))
	}
	if i.NameJaLTE != nil {
		predicates = append(predicates, cardspecialcolor.NameJaLTE(*i.NameJaLTE))
	}
	if i.NameJaContains != nil {
		predicates = append(predicates, cardspecialcolor.NameJaContains(*i.NameJaContains))
	}
	if i.NameJaHasPrefix != nil {
		predicates = append(predicates, cardspecialcolor.NameJaHasPrefix(*i.NameJaHasPrefix))
	}
	if i.NameJaHasSuffix != nil {
		predicates = append(predicates, cardspecialcolor.NameJaHasSuffix(*i.NameJaHasSuffix))
	}
	if i.NameJaIsNil {
		predicates = append(predicates, cardspecialcolor.NameJaIsNil())
	}
	if i.NameJaNotNil {
		predicates = append(predicates, cardspecialcolor.NameJaNotNil())
	}
	if i.NameJaEqualFold != nil {
		predicates = append(predicates, cardspecialcolor.NameJaEqualFold(*i.NameJaEqualFold))
	}
	if i.NameJaContainsFold != nil {
		predicates = append(predicates, cardspecialcolor.NameJaContainsFold(*i.NameJaContainsFold))
	}
	if i.NameEn != nil {
		predicates = append(predicates, cardspecialcolor.NameEnEQ(*i.NameEn))
	}
	if i.NameEnNEQ != nil {
		predicates = append(predicates, cardspecialcolor.NameEnNEQ(*i.NameEnNEQ))
	}
	if len(i.NameEnIn) > 0 {
		predicates = append(predicates, cardspecialcolor.NameEnIn(i.NameEnIn...))
	}
	if len(i.NameEnNotIn) > 0 {
		predicates = append(predicates, cardspecialcolor.NameEnNotIn(i.NameEnNotIn...))
	}
	if i.NameEnGT != nil {
		predicates = append(predicates, cardspecialcolor.NameEnGT(*i.NameEnGT))
	}
	if i.NameEnGTE != nil {
		predicates = append(predicates, cardspecialcolor.NameEnGTE(*i.NameEnGTE))
	}
	if i.NameEnLT != nil {
		predicates = append(predicates, cardspecialcolor.NameEnLT(*i.NameEnLT))
	}
	if i.NameEnLTE != nil {
		predicates = append(predicates, cardspecialcolor.NameEnLTE(*i.NameEnLTE))
	}
	if i.NameEnContains != nil {
		predicates = append(predicates, cardspecialcolor.NameEnContains(*i.NameEnContains))
	}
	if i.NameEnHasPrefix != nil {
		predicates = append(predicates, cardspecialcolor.NameEnHasPrefix(*i.NameEnHasPrefix))
	}
	if i.NameEnHasSuffix != nil {
		predicates = append(predicates, cardspecialcolor.NameEnHasSuffix(*i.NameEnHasSuffix))
	}
	if i.NameEnIsNil {
		predicates = append(predicates, cardspecialcolor.NameEnIsNil())
	}
	if i.NameEnNotNil {
		predicates = append(predicates, cardspecialcolor.NameEnNotNil())
	}
	if i.NameEnEqualFold != nil {
		predicates = append(predicates, cardspecialcolor.NameEnEqualFold(*i.NameEnEqualFold))
	}
	if i.NameEnContainsFold != nil {
		predicates = append(predicates, cardspecialcolor.NameEnContainsFold(*i.NameEnContainsFold))
	}

	if i.HasCards != nil {
		p := cardspecialcolor.HasCards()
		if !*i.HasCards {
			p = cardspecialcolor.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCardsWith) > 0 {
		with := make([]predicate.Card, 0, len(i.HasCardsWith))
		for _, w := range i.HasCardsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCardsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, cardspecialcolor.HasCardsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCardSpecialColorWhereInput
	case 1:
		return predicates[0], nil
	default:
		return cardspecialcolor.And(predicates...), nil
	}
}

// CardTypeWhereInput represents a where input for filtering CardType queries.
type CardTypeWhereInput struct {
	Predicates []predicate.CardType  `json:"-"`
	Not        *CardTypeWhereInput   `json:"not,omitempty"`
	Or         []*CardTypeWhereInput `json:"or,omitempty"`
	And        []*CardTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "name_ja" field predicates.
	NameJa             *string  `json:"nameJa,omitempty"`
	NameJaNEQ          *string  `json:"nameJaNEQ,omitempty"`
	NameJaIn           []string `json:"nameJaIn,omitempty"`
	NameJaNotIn        []string `json:"nameJaNotIn,omitempty"`
	NameJaGT           *string  `json:"nameJaGT,omitempty"`
	NameJaGTE          *string  `json:"nameJaGTE,omitempty"`
	NameJaLT           *string  `json:"nameJaLT,omitempty"`
	NameJaLTE          *string  `json:"nameJaLTE,omitempty"`
	NameJaContains     *string  `json:"nameJaContains,omitempty"`
	NameJaHasPrefix    *string  `json:"nameJaHasPrefix,omitempty"`
	NameJaHasSuffix    *string  `json:"nameJaHasSuffix,omitempty"`
	NameJaIsNil        bool     `json:"nameJaIsNil,omitempty"`
	NameJaNotNil       bool     `json:"nameJaNotNil,omitempty"`
	NameJaEqualFold    *string  `json:"nameJaEqualFold,omitempty"`
	NameJaContainsFold *string  `json:"nameJaContainsFold,omitempty"`

	// "name_en" field predicates.
	NameEn             *string  `json:"nameEn,omitempty"`
	NameEnNEQ          *string  `json:"nameEnNEQ,omitempty"`
	NameEnIn           []string `json:"nameEnIn,omitempty"`
	NameEnNotIn        []string `json:"nameEnNotIn,omitempty"`
	NameEnGT           *string  `json:"nameEnGT,omitempty"`
	NameEnGTE          *string  `json:"nameEnGTE,omitempty"`
	NameEnLT           *string  `json:"nameEnLT,omitempty"`
	NameEnLTE          *string  `json:"nameEnLTE,omitempty"`
	NameEnContains     *string  `json:"nameEnContains,omitempty"`
	NameEnHasPrefix    *string  `json:"nameEnHasPrefix,omitempty"`
	NameEnHasSuffix    *string  `json:"nameEnHasSuffix,omitempty"`
	NameEnIsNil        bool     `json:"nameEnIsNil,omitempty"`
	NameEnNotNil       bool     `json:"nameEnNotNil,omitempty"`
	NameEnEqualFold    *string  `json:"nameEnEqualFold,omitempty"`
	NameEnContainsFold *string  `json:"nameEnContainsFold,omitempty"`

	// "cards" edge predicates.
	HasCards     *bool             `json:"hasCards,omitempty"`
	HasCardsWith []*CardWhereInput `json:"hasCardsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CardTypeWhereInput) AddPredicates(predicates ...predicate.CardType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CardTypeWhereInput filter on the CardTypeQuery builder.
func (i *CardTypeWhereInput) Filter(q *CardTypeQuery) (*CardTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCardTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCardTypeWhereInput is returned in case the CardTypeWhereInput is empty.
var ErrEmptyCardTypeWhereInput = errors.New("ent: empty predicate CardTypeWhereInput")

// P returns a predicate for filtering cardtypes.
// An error is returned if the input is empty or invalid.
func (i *CardTypeWhereInput) P() (predicate.CardType, error) {
	var predicates []predicate.CardType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, cardtype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CardType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, cardtype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CardType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, cardtype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, cardtype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, cardtype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, cardtype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, cardtype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, cardtype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, cardtype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, cardtype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, cardtype.IDLTE(*i.IDLTE))
	}
	if i.Key != nil {
		predicates = append(predicates, cardtype.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, cardtype.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, cardtype.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, cardtype.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, cardtype.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, cardtype.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, cardtype.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, cardtype.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, cardtype.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, cardtype.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, cardtype.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, cardtype.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, cardtype.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.NameJa != nil {
		predicates = append(predicates, cardtype.NameJaEQ(*i.NameJa))
	}
	if i.NameJaNEQ != nil {
		predicates = append(predicates, cardtype.NameJaNEQ(*i.NameJaNEQ))
	}
	if len(i.NameJaIn) > 0 {
		predicates = append(predicates, cardtype.NameJaIn(i.NameJaIn...))
	}
	if len(i.NameJaNotIn) > 0 {
		predicates = append(predicates, cardtype.NameJaNotIn(i.NameJaNotIn...))
	}
	if i.NameJaGT != nil {
		predicates = append(predicates, cardtype.NameJaGT(*i.NameJaGT))
	}
	if i.NameJaGTE != nil {
		predicates = append(predicates, cardtype.NameJaGTE(*i.NameJaGTE))
	}
	if i.NameJaLT != nil {
		predicates = append(predicates, cardtype.NameJaLT(*i.NameJaLT))
	}
	if i.NameJaLTE != nil {
		predicates = append(predicates, cardtype.NameJaLTE(*i.NameJaLTE))
	}
	if i.NameJaContains != nil {
		predicates = append(predicates, cardtype.NameJaContains(*i.NameJaContains))
	}
	if i.NameJaHasPrefix != nil {
		predicates = append(predicates, cardtype.NameJaHasPrefix(*i.NameJaHasPrefix))
	}
	if i.NameJaHasSuffix != nil {
		predicates = append(predicates, cardtype.NameJaHasSuffix(*i.NameJaHasSuffix))
	}
	if i.NameJaIsNil {
		predicates = append(predicates, cardtype.NameJaIsNil())
	}
	if i.NameJaNotNil {
		predicates = append(predicates, cardtype.NameJaNotNil())
	}
	if i.NameJaEqualFold != nil {
		predicates = append(predicates, cardtype.NameJaEqualFold(*i.NameJaEqualFold))
	}
	if i.NameJaContainsFold != nil {
		predicates = append(predicates, cardtype.NameJaContainsFold(*i.NameJaContainsFold))
	}
	if i.NameEn != nil {
		predicates = append(predicates, cardtype.NameEnEQ(*i.NameEn))
	}
	if i.NameEnNEQ != nil {
		predicates = append(predicates, cardtype.NameEnNEQ(*i.NameEnNEQ))
	}
	if len(i.NameEnIn) > 0 {
		predicates = append(predicates, cardtype.NameEnIn(i.NameEnIn...))
	}
	if len(i.NameEnNotIn) > 0 {
		predicates = append(predicates, cardtype.NameEnNotIn(i.NameEnNotIn...))
	}
	if i.NameEnGT != nil {
		predicates = append(predicates, cardtype.NameEnGT(*i.NameEnGT))
	}
	if i.NameEnGTE != nil {
		predicates = append(predicates, cardtype.NameEnGTE(*i.NameEnGTE))
	}
	if i.NameEnLT != nil {
		predicates = append(predicates, cardtype.NameEnLT(*i.NameEnLT))
	}
	if i.NameEnLTE != nil {
		predicates = append(predicates, cardtype.NameEnLTE(*i.NameEnLTE))
	}
	if i.NameEnContains != nil {
		predicates = append(predicates, cardtype.NameEnContains(*i.NameEnContains))
	}
	if i.NameEnHasPrefix != nil {
		predicates = append(predicates, cardtype.NameEnHasPrefix(*i.NameEnHasPrefix))
	}
	if i.NameEnHasSuffix != nil {
		predicates = append(predicates, cardtype.NameEnHasSuffix(*i.NameEnHasSuffix))
	}
	if i.NameEnIsNil {
		predicates = append(predicates, cardtype.NameEnIsNil())
	}
	if i.NameEnNotNil {
		predicates = append(predicates, cardtype.NameEnNotNil())
	}
	if i.NameEnEqualFold != nil {
		predicates = append(predicates, cardtype.NameEnEqualFold(*i.NameEnEqualFold))
	}
	if i.NameEnContainsFold != nil {
		predicates = append(predicates, cardtype.NameEnContainsFold(*i.NameEnContainsFold))
	}

	if i.HasCards != nil {
		p := cardtype.HasCards()
		if !*i.HasCards {
			p = cardtype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCardsWith) > 0 {
		with := make([]predicate.Card, 0, len(i.HasCardsWith))
		for _, w := range i.HasCardsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCardsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, cardtype.HasCardsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCardTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return cardtype.And(predicates...), nil
	}
}

// DeckWhereInput represents a where input for filtering Deck queries.
type DeckWhereInput struct {
	Predicates []predicate.Deck  `json:"-"`
	Not        *DeckWhereInput   `json:"not,omitempty"`
	Or         []*DeckWhereInput `json:"or,omitempty"`
	And        []*DeckWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "revision_id" field predicates.
	RevisionID      *int  `json:"revisionID,omitempty"`
	RevisionIDNEQ   *int  `json:"revisionIDNEQ,omitempty"`
	RevisionIDIn    []int `json:"revisionIDIn,omitempty"`
	RevisionIDNotIn []int `json:"revisionIDNotIn,omitempty"`

	// "name_ja" field predicates.
	NameJa             *string  `json:"nameJa,omitempty"`
	NameJaNEQ          *string  `json:"nameJaNEQ,omitempty"`
	NameJaIn           []string `json:"nameJaIn,omitempty"`
	NameJaNotIn        []string `json:"nameJaNotIn,omitempty"`
	NameJaGT           *string  `json:"nameJaGT,omitempty"`
	NameJaGTE          *string  `json:"nameJaGTE,omitempty"`
	NameJaLT           *string  `json:"nameJaLT,omitempty"`
	NameJaLTE          *string  `json:"nameJaLTE,omitempty"`
	NameJaContains     *string  `json:"nameJaContains,omitempty"`
	NameJaHasPrefix    *string  `json:"nameJaHasPrefix,omitempty"`
	NameJaHasSuffix    *string  `json:"nameJaHasSuffix,omitempty"`
	NameJaIsNil        bool     `json:"nameJaIsNil,omitempty"`
	NameJaNotNil       bool     `json:"nameJaNotNil,omitempty"`
	NameJaEqualFold    *string  `json:"nameJaEqualFold,omitempty"`
	NameJaContainsFold *string  `json:"nameJaContainsFold,omitempty"`

	// "name_en" field predicates.
	NameEn             *string  `json:"nameEn,omitempty"`
	NameEnNEQ          *string  `json:"nameEnNEQ,omitempty"`
	NameEnIn           []string `json:"nameEnIn,omitempty"`
	NameEnNotIn        []string `json:"nameEnNotIn,omitempty"`
	NameEnGT           *string  `json:"nameEnGT,omitempty"`
	NameEnGTE          *string  `json:"nameEnGTE,omitempty"`
	NameEnLT           *string  `json:"nameEnLT,omitempty"`
	NameEnLTE          *string  `json:"nameEnLTE,omitempty"`
	NameEnContains     *string  `json:"nameEnContains,omitempty"`
	NameEnHasPrefix    *string  `json:"nameEnHasPrefix,omitempty"`
	NameEnHasSuffix    *string  `json:"nameEnHasSuffix,omitempty"`
	NameEnIsNil        bool     `json:"nameEnIsNil,omitempty"`
	NameEnNotNil       bool     `json:"nameEnNotNil,omitempty"`
	NameEnEqualFold    *string  `json:"nameEnEqualFold,omitempty"`
	NameEnContainsFold *string  `json:"nameEnContainsFold,omitempty"`

	// "cards" edge predicates.
	HasCards     *bool             `json:"hasCards,omitempty"`
	HasCardsWith []*CardWhereInput `json:"hasCardsWith,omitempty"`

	// "revision" edge predicates.
	HasRevision     *bool                 `json:"hasRevision,omitempty"`
	HasRevisionWith []*RevisionWhereInput `json:"hasRevisionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DeckWhereInput) AddPredicates(predicates ...predicate.Deck) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DeckWhereInput filter on the DeckQuery builder.
func (i *DeckWhereInput) Filter(q *DeckQuery) (*DeckQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDeckWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDeckWhereInput is returned in case the DeckWhereInput is empty.
var ErrEmptyDeckWhereInput = errors.New("ent: empty predicate DeckWhereInput")

// P returns a predicate for filtering decks.
// An error is returned if the input is empty or invalid.
func (i *DeckWhereInput) P() (predicate.Deck, error) {
	var predicates []predicate.Deck
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, deck.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Deck, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, deck.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Deck, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, deck.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, deck.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deck.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deck.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deck.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deck.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deck.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deck.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deck.IDLTE(*i.IDLTE))
	}
	if i.Key != nil {
		predicates = append(predicates, deck.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, deck.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, deck.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, deck.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, deck.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, deck.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, deck.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, deck.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, deck.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, deck.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, deck.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, deck.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, deck.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.RevisionID != nil {
		predicates = append(predicates, deck.RevisionIDEQ(*i.RevisionID))
	}
	if i.RevisionIDNEQ != nil {
		predicates = append(predicates, deck.RevisionIDNEQ(*i.RevisionIDNEQ))
	}
	if len(i.RevisionIDIn) > 0 {
		predicates = append(predicates, deck.RevisionIDIn(i.RevisionIDIn...))
	}
	if len(i.RevisionIDNotIn) > 0 {
		predicates = append(predicates, deck.RevisionIDNotIn(i.RevisionIDNotIn...))
	}
	if i.NameJa != nil {
		predicates = append(predicates, deck.NameJaEQ(*i.NameJa))
	}
	if i.NameJaNEQ != nil {
		predicates = append(predicates, deck.NameJaNEQ(*i.NameJaNEQ))
	}
	if len(i.NameJaIn) > 0 {
		predicates = append(predicates, deck.NameJaIn(i.NameJaIn...))
	}
	if len(i.NameJaNotIn) > 0 {
		predicates = append(predicates, deck.NameJaNotIn(i.NameJaNotIn...))
	}
	if i.NameJaGT != nil {
		predicates = append(predicates, deck.NameJaGT(*i.NameJaGT))
	}
	if i.NameJaGTE != nil {
		predicates = append(predicates, deck.NameJaGTE(*i.NameJaGTE))
	}
	if i.NameJaLT != nil {
		predicates = append(predicates, deck.NameJaLT(*i.NameJaLT))
	}
	if i.NameJaLTE != nil {
		predicates = append(predicates, deck.NameJaLTE(*i.NameJaLTE))
	}
	if i.NameJaContains != nil {
		predicates = append(predicates, deck.NameJaContains(*i.NameJaContains))
	}
	if i.NameJaHasPrefix != nil {
		predicates = append(predicates, deck.NameJaHasPrefix(*i.NameJaHasPrefix))
	}
	if i.NameJaHasSuffix != nil {
		predicates = append(predicates, deck.NameJaHasSuffix(*i.NameJaHasSuffix))
	}
	if i.NameJaIsNil {
		predicates = append(predicates, deck.NameJaIsNil())
	}
	if i.NameJaNotNil {
		predicates = append(predicates, deck.NameJaNotNil())
	}
	if i.NameJaEqualFold != nil {
		predicates = append(predicates, deck.NameJaEqualFold(*i.NameJaEqualFold))
	}
	if i.NameJaContainsFold != nil {
		predicates = append(predicates, deck.NameJaContainsFold(*i.NameJaContainsFold))
	}
	if i.NameEn != nil {
		predicates = append(predicates, deck.NameEnEQ(*i.NameEn))
	}
	if i.NameEnNEQ != nil {
		predicates = append(predicates, deck.NameEnNEQ(*i.NameEnNEQ))
	}
	if len(i.NameEnIn) > 0 {
		predicates = append(predicates, deck.NameEnIn(i.NameEnIn...))
	}
	if len(i.NameEnNotIn) > 0 {
		predicates = append(predicates, deck.NameEnNotIn(i.NameEnNotIn...))
	}
	if i.NameEnGT != nil {
		predicates = append(predicates, deck.NameEnGT(*i.NameEnGT))
	}
	if i.NameEnGTE != nil {
		predicates = append(predicates, deck.NameEnGTE(*i.NameEnGTE))
	}
	if i.NameEnLT != nil {
		predicates = append(predicates, deck.NameEnLT(*i.NameEnLT))
	}
	if i.NameEnLTE != nil {
		predicates = append(predicates, deck.NameEnLTE(*i.NameEnLTE))
	}
	if i.NameEnContains != nil {
		predicates = append(predicates, deck.NameEnContains(*i.NameEnContains))
	}
	if i.NameEnHasPrefix != nil {
		predicates = append(predicates, deck.NameEnHasPrefix(*i.NameEnHasPrefix))
	}
	if i.NameEnHasSuffix != nil {
		predicates = append(predicates, deck.NameEnHasSuffix(*i.NameEnHasSuffix))
	}
	if i.NameEnIsNil {
		predicates = append(predicates, deck.NameEnIsNil())
	}
	if i.NameEnNotNil {
		predicates = append(predicates, deck.NameEnNotNil())
	}
	if i.NameEnEqualFold != nil {
		predicates = append(predicates, deck.NameEnEqualFold(*i.NameEnEqualFold))
	}
	if i.NameEnContainsFold != nil {
		predicates = append(predicates, deck.NameEnContainsFold(*i.NameEnContainsFold))
	}

	if i.HasCards != nil {
		p := deck.HasCards()
		if !*i.HasCards {
			p = deck.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCardsWith) > 0 {
		with := make([]predicate.Card, 0, len(i.HasCardsWith))
		for _, w := range i.HasCardsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCardsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deck.HasCardsWith(with...))
	}
	if i.HasRevision != nil {
		p := deck.HasRevision()
		if !*i.HasRevision {
			p = deck.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRevisionWith) > 0 {
		with := make([]predicate.Revision, 0, len(i.HasRevisionWith))
		for _, w := range i.HasRevisionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRevisionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deck.HasRevisionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDeckWhereInput
	case 1:
		return predicates[0], nil
	default:
		return deck.And(predicates...), nil
	}
}

// ProductWhereInput represents a where input for filtering Product queries.
type ProductWhereInput struct {
	Predicates []predicate.Product  `json:"-"`
	Not        *ProductWhereInput   `json:"not,omitempty"`
	Or         []*ProductWhereInput `json:"or,omitempty"`
	And        []*ProductWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "revision_id" field predicates.
	RevisionID      *int  `json:"revisionID,omitempty"`
	RevisionIDNEQ   *int  `json:"revisionIDNEQ,omitempty"`
	RevisionIDIn    []int `json:"revisionIDIn,omitempty"`
	RevisionIDNotIn []int `json:"revisionIDNotIn,omitempty"`

	// "is_official_ja" field predicates.
	IsOfficialJa    *bool `json:"isOfficialJa,omitempty"`
	IsOfficialJaNEQ *bool `json:"isOfficialJaNEQ,omitempty"`

	// "name_ja" field predicates.
	NameJa             *string  `json:"nameJa,omitempty"`
	NameJaNEQ          *string  `json:"nameJaNEQ,omitempty"`
	NameJaIn           []string `json:"nameJaIn,omitempty"`
	NameJaNotIn        []string `json:"nameJaNotIn,omitempty"`
	NameJaGT           *string  `json:"nameJaGT,omitempty"`
	NameJaGTE          *string  `json:"nameJaGTE,omitempty"`
	NameJaLT           *string  `json:"nameJaLT,omitempty"`
	NameJaLTE          *string  `json:"nameJaLTE,omitempty"`
	NameJaContains     *string  `json:"nameJaContains,omitempty"`
	NameJaHasPrefix    *string  `json:"nameJaHasPrefix,omitempty"`
	NameJaHasSuffix    *string  `json:"nameJaHasSuffix,omitempty"`
	NameJaIsNil        bool     `json:"nameJaIsNil,omitempty"`
	NameJaNotNil       bool     `json:"nameJaNotNil,omitempty"`
	NameJaEqualFold    *string  `json:"nameJaEqualFold,omitempty"`
	NameJaContainsFold *string  `json:"nameJaContainsFold,omitempty"`

	// "name_en" field predicates.
	NameEn             *string  `json:"nameEn,omitempty"`
	NameEnNEQ          *string  `json:"nameEnNEQ,omitempty"`
	NameEnIn           []string `json:"nameEnIn,omitempty"`
	NameEnNotIn        []string `json:"nameEnNotIn,omitempty"`
	NameEnGT           *string  `json:"nameEnGT,omitempty"`
	NameEnGTE          *string  `json:"nameEnGTE,omitempty"`
	NameEnLT           *string  `json:"nameEnLT,omitempty"`
	NameEnLTE          *string  `json:"nameEnLTE,omitempty"`
	NameEnContains     *string  `json:"nameEnContains,omitempty"`
	NameEnHasPrefix    *string  `json:"nameEnHasPrefix,omitempty"`
	NameEnHasSuffix    *string  `json:"nameEnHasSuffix,omitempty"`
	NameEnIsNil        bool     `json:"nameEnIsNil,omitempty"`
	NameEnNotNil       bool     `json:"nameEnNotNil,omitempty"`
	NameEnEqualFold    *string  `json:"nameEnEqualFold,omitempty"`
	NameEnContainsFold *string  `json:"nameEnContainsFold,omitempty"`

	// "published_year" field predicates.
	PublishedYear       *int  `json:"publishedYear,omitempty"`
	PublishedYearNEQ    *int  `json:"publishedYearNEQ,omitempty"`
	PublishedYearIn     []int `json:"publishedYearIn,omitempty"`
	PublishedYearNotIn  []int `json:"publishedYearNotIn,omitempty"`
	PublishedYearGT     *int  `json:"publishedYearGT,omitempty"`
	PublishedYearGTE    *int  `json:"publishedYearGTE,omitempty"`
	PublishedYearLT     *int  `json:"publishedYearLT,omitempty"`
	PublishedYearLTE    *int  `json:"publishedYearLTE,omitempty"`
	PublishedYearIsNil  bool  `json:"publishedYearIsNil,omitempty"`
	PublishedYearNotNil bool  `json:"publishedYearNotNil,omitempty"`

	// "cards" edge predicates.
	HasCards     *bool             `json:"hasCards,omitempty"`
	HasCardsWith []*CardWhereInput `json:"hasCardsWith,omitempty"`

	// "revision" edge predicates.
	HasRevision     *bool                 `json:"hasRevision,omitempty"`
	HasRevisionWith []*RevisionWhereInput `json:"hasRevisionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProductWhereInput) AddPredicates(predicates ...predicate.Product) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProductWhereInput filter on the ProductQuery builder.
func (i *ProductWhereInput) Filter(q *ProductQuery) (*ProductQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProductWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProductWhereInput is returned in case the ProductWhereInput is empty.
var ErrEmptyProductWhereInput = errors.New("ent: empty predicate ProductWhereInput")

// P returns a predicate for filtering products.
// An error is returned if the input is empty or invalid.
func (i *ProductWhereInput) P() (predicate.Product, error) {
	var predicates []predicate.Product
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, product.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Product, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, product.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Product, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, product.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, product.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, product.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, product.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, product.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, product.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, product.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, product.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, product.IDLTE(*i.IDLTE))
	}
	if i.RevisionID != nil {
		predicates = append(predicates, product.RevisionIDEQ(*i.RevisionID))
	}
	if i.RevisionIDNEQ != nil {
		predicates = append(predicates, product.RevisionIDNEQ(*i.RevisionIDNEQ))
	}
	if len(i.RevisionIDIn) > 0 {
		predicates = append(predicates, product.RevisionIDIn(i.RevisionIDIn...))
	}
	if len(i.RevisionIDNotIn) > 0 {
		predicates = append(predicates, product.RevisionIDNotIn(i.RevisionIDNotIn...))
	}
	if i.IsOfficialJa != nil {
		predicates = append(predicates, product.IsOfficialJaEQ(*i.IsOfficialJa))
	}
	if i.IsOfficialJaNEQ != nil {
		predicates = append(predicates, product.IsOfficialJaNEQ(*i.IsOfficialJaNEQ))
	}
	if i.NameJa != nil {
		predicates = append(predicates, product.NameJaEQ(*i.NameJa))
	}
	if i.NameJaNEQ != nil {
		predicates = append(predicates, product.NameJaNEQ(*i.NameJaNEQ))
	}
	if len(i.NameJaIn) > 0 {
		predicates = append(predicates, product.NameJaIn(i.NameJaIn...))
	}
	if len(i.NameJaNotIn) > 0 {
		predicates = append(predicates, product.NameJaNotIn(i.NameJaNotIn...))
	}
	if i.NameJaGT != nil {
		predicates = append(predicates, product.NameJaGT(*i.NameJaGT))
	}
	if i.NameJaGTE != nil {
		predicates = append(predicates, product.NameJaGTE(*i.NameJaGTE))
	}
	if i.NameJaLT != nil {
		predicates = append(predicates, product.NameJaLT(*i.NameJaLT))
	}
	if i.NameJaLTE != nil {
		predicates = append(predicates, product.NameJaLTE(*i.NameJaLTE))
	}
	if i.NameJaContains != nil {
		predicates = append(predicates, product.NameJaContains(*i.NameJaContains))
	}
	if i.NameJaHasPrefix != nil {
		predicates = append(predicates, product.NameJaHasPrefix(*i.NameJaHasPrefix))
	}
	if i.NameJaHasSuffix != nil {
		predicates = append(predicates, product.NameJaHasSuffix(*i.NameJaHasSuffix))
	}
	if i.NameJaIsNil {
		predicates = append(predicates, product.NameJaIsNil())
	}
	if i.NameJaNotNil {
		predicates = append(predicates, product.NameJaNotNil())
	}
	if i.NameJaEqualFold != nil {
		predicates = append(predicates, product.NameJaEqualFold(*i.NameJaEqualFold))
	}
	if i.NameJaContainsFold != nil {
		predicates = append(predicates, product.NameJaContainsFold(*i.NameJaContainsFold))
	}
	if i.NameEn != nil {
		predicates = append(predicates, product.NameEnEQ(*i.NameEn))
	}
	if i.NameEnNEQ != nil {
		predicates = append(predicates, product.NameEnNEQ(*i.NameEnNEQ))
	}
	if len(i.NameEnIn) > 0 {
		predicates = append(predicates, product.NameEnIn(i.NameEnIn...))
	}
	if len(i.NameEnNotIn) > 0 {
		predicates = append(predicates, product.NameEnNotIn(i.NameEnNotIn...))
	}
	if i.NameEnGT != nil {
		predicates = append(predicates, product.NameEnGT(*i.NameEnGT))
	}
	if i.NameEnGTE != nil {
		predicates = append(predicates, product.NameEnGTE(*i.NameEnGTE))
	}
	if i.NameEnLT != nil {
		predicates = append(predicates, product.NameEnLT(*i.NameEnLT))
	}
	if i.NameEnLTE != nil {
		predicates = append(predicates, product.NameEnLTE(*i.NameEnLTE))
	}
	if i.NameEnContains != nil {
		predicates = append(predicates, product.NameEnContains(*i.NameEnContains))
	}
	if i.NameEnHasPrefix != nil {
		predicates = append(predicates, product.NameEnHasPrefix(*i.NameEnHasPrefix))
	}
	if i.NameEnHasSuffix != nil {
		predicates = append(predicates, product.NameEnHasSuffix(*i.NameEnHasSuffix))
	}
	if i.NameEnIsNil {
		predicates = append(predicates, product.NameEnIsNil())
	}
	if i.NameEnNotNil {
		predicates = append(predicates, product.NameEnNotNil())
	}
	if i.NameEnEqualFold != nil {
		predicates = append(predicates, product.NameEnEqualFold(*i.NameEnEqualFold))
	}
	if i.NameEnContainsFold != nil {
		predicates = append(predicates, product.NameEnContainsFold(*i.NameEnContainsFold))
	}
	if i.PublishedYear != nil {
		predicates = append(predicates, product.PublishedYearEQ(*i.PublishedYear))
	}
	if i.PublishedYearNEQ != nil {
		predicates = append(predicates, product.PublishedYearNEQ(*i.PublishedYearNEQ))
	}
	if len(i.PublishedYearIn) > 0 {
		predicates = append(predicates, product.PublishedYearIn(i.PublishedYearIn...))
	}
	if len(i.PublishedYearNotIn) > 0 {
		predicates = append(predicates, product.PublishedYearNotIn(i.PublishedYearNotIn...))
	}
	if i.PublishedYearGT != nil {
		predicates = append(predicates, product.PublishedYearGT(*i.PublishedYearGT))
	}
	if i.PublishedYearGTE != nil {
		predicates = append(predicates, product.PublishedYearGTE(*i.PublishedYearGTE))
	}
	if i.PublishedYearLT != nil {
		predicates = append(predicates, product.PublishedYearLT(*i.PublishedYearLT))
	}
	if i.PublishedYearLTE != nil {
		predicates = append(predicates, product.PublishedYearLTE(*i.PublishedYearLTE))
	}
	if i.PublishedYearIsNil {
		predicates = append(predicates, product.PublishedYearIsNil())
	}
	if i.PublishedYearNotNil {
		predicates = append(predicates, product.PublishedYearNotNil())
	}

	if i.HasCards != nil {
		p := product.HasCards()
		if !*i.HasCards {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCardsWith) > 0 {
		with := make([]predicate.Card, 0, len(i.HasCardsWith))
		for _, w := range i.HasCardsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCardsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasCardsWith(with...))
	}
	if i.HasRevision != nil {
		p := product.HasRevision()
		if !*i.HasRevision {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRevisionWith) > 0 {
		with := make([]predicate.Revision, 0, len(i.HasRevisionWith))
		for _, w := range i.HasRevisionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRevisionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasRevisionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProductWhereInput
	case 1:
		return predicates[0], nil
	default:
		return product.And(predicates...), nil
	}
}

// RevisionWhereInput represents a where input for filtering Revision queries.
type RevisionWhereInput struct {
	Predicates []predicate.Revision  `json:"-"`
	Not        *RevisionWhereInput   `json:"not,omitempty"`
	Or         []*RevisionWhereInput `json:"or,omitempty"`
	And        []*RevisionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "name_ja" field predicates.
	NameJa             *string  `json:"nameJa,omitempty"`
	NameJaNEQ          *string  `json:"nameJaNEQ,omitempty"`
	NameJaIn           []string `json:"nameJaIn,omitempty"`
	NameJaNotIn        []string `json:"nameJaNotIn,omitempty"`
	NameJaGT           *string  `json:"nameJaGT,omitempty"`
	NameJaGTE          *string  `json:"nameJaGTE,omitempty"`
	NameJaLT           *string  `json:"nameJaLT,omitempty"`
	NameJaLTE          *string  `json:"nameJaLTE,omitempty"`
	NameJaContains     *string  `json:"nameJaContains,omitempty"`
	NameJaHasPrefix    *string  `json:"nameJaHasPrefix,omitempty"`
	NameJaHasSuffix    *string  `json:"nameJaHasSuffix,omitempty"`
	NameJaIsNil        bool     `json:"nameJaIsNil,omitempty"`
	NameJaNotNil       bool     `json:"nameJaNotNil,omitempty"`
	NameJaEqualFold    *string  `json:"nameJaEqualFold,omitempty"`
	NameJaContainsFold *string  `json:"nameJaContainsFold,omitempty"`

	// "name_en" field predicates.
	NameEn             *string  `json:"nameEn,omitempty"`
	NameEnNEQ          *string  `json:"nameEnNEQ,omitempty"`
	NameEnIn           []string `json:"nameEnIn,omitempty"`
	NameEnNotIn        []string `json:"nameEnNotIn,omitempty"`
	NameEnGT           *string  `json:"nameEnGT,omitempty"`
	NameEnGTE          *string  `json:"nameEnGTE,omitempty"`
	NameEnLT           *string  `json:"nameEnLT,omitempty"`
	NameEnLTE          *string  `json:"nameEnLTE,omitempty"`
	NameEnContains     *string  `json:"nameEnContains,omitempty"`
	NameEnHasPrefix    *string  `json:"nameEnHasPrefix,omitempty"`
	NameEnHasSuffix    *string  `json:"nameEnHasSuffix,omitempty"`
	NameEnIsNil        bool     `json:"nameEnIsNil,omitempty"`
	NameEnNotNil       bool     `json:"nameEnNotNil,omitempty"`
	NameEnEqualFold    *string  `json:"nameEnEqualFold,omitempty"`
	NameEnContainsFold *string  `json:"nameEnContainsFold,omitempty"`

	// "cards" edge predicates.
	HasCards     *bool             `json:"hasCards,omitempty"`
	HasCardsWith []*CardWhereInput `json:"hasCardsWith,omitempty"`

	// "products" edge predicates.
	HasProducts     *bool                `json:"hasProducts,omitempty"`
	HasProductsWith []*ProductWhereInput `json:"hasProductsWith,omitempty"`

	// "decks" edge predicates.
	HasDecks     *bool             `json:"hasDecks,omitempty"`
	HasDecksWith []*DeckWhereInput `json:"hasDecksWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RevisionWhereInput) AddPredicates(predicates ...predicate.Revision) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RevisionWhereInput filter on the RevisionQuery builder.
func (i *RevisionWhereInput) Filter(q *RevisionQuery) (*RevisionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRevisionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRevisionWhereInput is returned in case the RevisionWhereInput is empty.
var ErrEmptyRevisionWhereInput = errors.New("ent: empty predicate RevisionWhereInput")

// P returns a predicate for filtering revisions.
// An error is returned if the input is empty or invalid.
func (i *RevisionWhereInput) P() (predicate.Revision, error) {
	var predicates []predicate.Revision
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, revision.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Revision, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, revision.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Revision, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, revision.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, revision.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, revision.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, revision.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, revision.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, revision.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, revision.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, revision.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, revision.IDLTE(*i.IDLTE))
	}
	if i.Key != nil {
		predicates = append(predicates, revision.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, revision.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, revision.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, revision.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, revision.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, revision.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, revision.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, revision.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, revision.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, revision.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, revision.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, revision.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, revision.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.NameJa != nil {
		predicates = append(predicates, revision.NameJaEQ(*i.NameJa))
	}
	if i.NameJaNEQ != nil {
		predicates = append(predicates, revision.NameJaNEQ(*i.NameJaNEQ))
	}
	if len(i.NameJaIn) > 0 {
		predicates = append(predicates, revision.NameJaIn(i.NameJaIn...))
	}
	if len(i.NameJaNotIn) > 0 {
		predicates = append(predicates, revision.NameJaNotIn(i.NameJaNotIn...))
	}
	if i.NameJaGT != nil {
		predicates = append(predicates, revision.NameJaGT(*i.NameJaGT))
	}
	if i.NameJaGTE != nil {
		predicates = append(predicates, revision.NameJaGTE(*i.NameJaGTE))
	}
	if i.NameJaLT != nil {
		predicates = append(predicates, revision.NameJaLT(*i.NameJaLT))
	}
	if i.NameJaLTE != nil {
		predicates = append(predicates, revision.NameJaLTE(*i.NameJaLTE))
	}
	if i.NameJaContains != nil {
		predicates = append(predicates, revision.NameJaContains(*i.NameJaContains))
	}
	if i.NameJaHasPrefix != nil {
		predicates = append(predicates, revision.NameJaHasPrefix(*i.NameJaHasPrefix))
	}
	if i.NameJaHasSuffix != nil {
		predicates = append(predicates, revision.NameJaHasSuffix(*i.NameJaHasSuffix))
	}
	if i.NameJaIsNil {
		predicates = append(predicates, revision.NameJaIsNil())
	}
	if i.NameJaNotNil {
		predicates = append(predicates, revision.NameJaNotNil())
	}
	if i.NameJaEqualFold != nil {
		predicates = append(predicates, revision.NameJaEqualFold(*i.NameJaEqualFold))
	}
	if i.NameJaContainsFold != nil {
		predicates = append(predicates, revision.NameJaContainsFold(*i.NameJaContainsFold))
	}
	if i.NameEn != nil {
		predicates = append(predicates, revision.NameEnEQ(*i.NameEn))
	}
	if i.NameEnNEQ != nil {
		predicates = append(predicates, revision.NameEnNEQ(*i.NameEnNEQ))
	}
	if len(i.NameEnIn) > 0 {
		predicates = append(predicates, revision.NameEnIn(i.NameEnIn...))
	}
	if len(i.NameEnNotIn) > 0 {
		predicates = append(predicates, revision.NameEnNotIn(i.NameEnNotIn...))
	}
	if i.NameEnGT != nil {
		predicates = append(predicates, revision.NameEnGT(*i.NameEnGT))
	}
	if i.NameEnGTE != nil {
		predicates = append(predicates, revision.NameEnGTE(*i.NameEnGTE))
	}
	if i.NameEnLT != nil {
		predicates = append(predicates, revision.NameEnLT(*i.NameEnLT))
	}
	if i.NameEnLTE != nil {
		predicates = append(predicates, revision.NameEnLTE(*i.NameEnLTE))
	}
	if i.NameEnContains != nil {
		predicates = append(predicates, revision.NameEnContains(*i.NameEnContains))
	}
	if i.NameEnHasPrefix != nil {
		predicates = append(predicates, revision.NameEnHasPrefix(*i.NameEnHasPrefix))
	}
	if i.NameEnHasSuffix != nil {
		predicates = append(predicates, revision.NameEnHasSuffix(*i.NameEnHasSuffix))
	}
	if i.NameEnIsNil {
		predicates = append(predicates, revision.NameEnIsNil())
	}
	if i.NameEnNotNil {
		predicates = append(predicates, revision.NameEnNotNil())
	}
	if i.NameEnEqualFold != nil {
		predicates = append(predicates, revision.NameEnEqualFold(*i.NameEnEqualFold))
	}
	if i.NameEnContainsFold != nil {
		predicates = append(predicates, revision.NameEnContainsFold(*i.NameEnContainsFold))
	}

	if i.HasCards != nil {
		p := revision.HasCards()
		if !*i.HasCards {
			p = revision.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCardsWith) > 0 {
		with := make([]predicate.Card, 0, len(i.HasCardsWith))
		for _, w := range i.HasCardsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCardsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, revision.HasCardsWith(with...))
	}
	if i.HasProducts != nil {
		p := revision.HasProducts()
		if !*i.HasProducts {
			p = revision.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductsWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductsWith))
		for _, w := range i.HasProductsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, revision.HasProductsWith(with...))
	}
	if i.HasDecks != nil {
		p := revision.HasDecks()
		if !*i.HasDecks {
			p = revision.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDecksWith) > 0 {
		with := make([]predicate.Deck, 0, len(i.HasDecksWith))
		for _, w := range i.HasDecksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDecksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, revision.HasDecksWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRevisionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return revision.And(predicates...), nil
	}
}
