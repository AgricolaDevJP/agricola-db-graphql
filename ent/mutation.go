// Code generated by ent, DO NOT EDIT.

package ent

import (
	"agricoladb/ent/card"
	"agricoladb/ent/cardspecialcolor"
	"agricoladb/ent/cardtype"
	"agricoladb/ent/deck"
	"agricoladb/ent/predicate"
	"agricoladb/ent/product"
	"agricoladb/ent/revision"
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCard             = "Card"
	TypeCardSpecialColor = "CardSpecialColor"
	TypeCardType         = "CardType"
	TypeDeck             = "Deck"
	TypeProduct          = "Product"
	TypeRevision         = "Revision"
)

// CardMutation represents an operation that mutates the Card nodes in the graph.
type CardMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	literal_id                          *string
	printed_id                          *string
	play_agricola_card_id               *string
	name_ja                             *string
	name_en                             *string
	min_players_number                  *int
	addmin_players_number               *int
	prerequisite                        *string
	cost                                *string
	description                         *string
	is_official_ja                      *bool
	victory_point                       *int
	addvictory_point                    *int
	special_victory_point               *string
	has_arrrow                          *bool
	has_bonus_point_icon                *bool
	has_negative_bonus_point_icon       *bool
	has_pan_icon                        *bool
	has_bread_icon                      *bool
	has_farm_planner_icon               *bool
	has_actions_booster_icon            *bool
	has_points_provider_icon            *bool
	has_goods_provider_icon             *bool
	has_food_provider_icon              *bool
	has_crop_provider_icon              *bool
	has_building_resource_provider_icon *bool
	has_livestock_provider_icon         *bool
	has_cut_peat_icon                   *bool
	has_fell_trees_icon                 *bool
	has_slash_and_burn_icon             *bool
	has_hiring_fare_icon                *bool
	clearedFields                       map[string]struct{}
	revision                            *int
	clearedrevision                     bool
	products                            map[int]struct{}
	removedproducts                     map[int]struct{}
	clearedproducts                     bool
	deck                                *int
	cleareddeck                         bool
	card_type                           *int
	clearedcard_type                    bool
	card_special_color                  *int
	clearedcard_special_color           bool
	children                            map[int]struct{}
	removedchildren                     map[int]struct{}
	clearedchildren                     bool
	ancestors                           map[int]struct{}
	removedancestors                    map[int]struct{}
	clearedancestors                    bool
	done                                bool
	oldValue                            func(context.Context) (*Card, error)
	predicates                          []predicate.Card
}

var _ ent.Mutation = (*CardMutation)(nil)

// cardOption allows management of the mutation configuration using functional options.
type cardOption func(*CardMutation)

// newCardMutation creates new mutation for the Card entity.
func newCardMutation(c config, op Op, opts ...cardOption) *CardMutation {
	m := &CardMutation{
		config:        c,
		op:            op,
		typ:           TypeCard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCardID sets the ID field of the mutation.
func withCardID(id int) cardOption {
	return func(m *CardMutation) {
		var (
			err   error
			once  sync.Once
			value *Card
		)
		m.oldValue = func(ctx context.Context) (*Card, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Card.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCard sets the old Card of the mutation.
func withCard(node *Card) cardOption {
	return func(m *CardMutation) {
		m.oldValue = func(context.Context) (*Card, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CardMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CardMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Card.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLiteralID sets the "literal_id" field.
func (m *CardMutation) SetLiteralID(s string) {
	m.literal_id = &s
}

// LiteralID returns the value of the "literal_id" field in the mutation.
func (m *CardMutation) LiteralID() (r string, exists bool) {
	v := m.literal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLiteralID returns the old "literal_id" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldLiteralID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLiteralID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLiteralID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLiteralID: %w", err)
	}
	return oldValue.LiteralID, nil
}

// ResetLiteralID resets all changes to the "literal_id" field.
func (m *CardMutation) ResetLiteralID() {
	m.literal_id = nil
}

// SetRevisionID sets the "revision_id" field.
func (m *CardMutation) SetRevisionID(i int) {
	m.revision = &i
}

// RevisionID returns the value of the "revision_id" field in the mutation.
func (m *CardMutation) RevisionID() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevisionID returns the old "revision_id" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldRevisionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevisionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevisionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevisionID: %w", err)
	}
	return oldValue.RevisionID, nil
}

// ResetRevisionID resets all changes to the "revision_id" field.
func (m *CardMutation) ResetRevisionID() {
	m.revision = nil
}

// SetPrintedID sets the "printed_id" field.
func (m *CardMutation) SetPrintedID(s string) {
	m.printed_id = &s
}

// PrintedID returns the value of the "printed_id" field in the mutation.
func (m *CardMutation) PrintedID() (r string, exists bool) {
	v := m.printed_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPrintedID returns the old "printed_id" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldPrintedID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrintedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrintedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrintedID: %w", err)
	}
	return oldValue.PrintedID, nil
}

// ClearPrintedID clears the value of the "printed_id" field.
func (m *CardMutation) ClearPrintedID() {
	m.printed_id = nil
	m.clearedFields[card.FieldPrintedID] = struct{}{}
}

// PrintedIDCleared returns if the "printed_id" field was cleared in this mutation.
func (m *CardMutation) PrintedIDCleared() bool {
	_, ok := m.clearedFields[card.FieldPrintedID]
	return ok
}

// ResetPrintedID resets all changes to the "printed_id" field.
func (m *CardMutation) ResetPrintedID() {
	m.printed_id = nil
	delete(m.clearedFields, card.FieldPrintedID)
}

// SetPlayAgricolaCardID sets the "play_agricola_card_id" field.
func (m *CardMutation) SetPlayAgricolaCardID(s string) {
	m.play_agricola_card_id = &s
}

// PlayAgricolaCardID returns the value of the "play_agricola_card_id" field in the mutation.
func (m *CardMutation) PlayAgricolaCardID() (r string, exists bool) {
	v := m.play_agricola_card_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayAgricolaCardID returns the old "play_agricola_card_id" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldPlayAgricolaCardID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayAgricolaCardID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayAgricolaCardID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayAgricolaCardID: %w", err)
	}
	return oldValue.PlayAgricolaCardID, nil
}

// ClearPlayAgricolaCardID clears the value of the "play_agricola_card_id" field.
func (m *CardMutation) ClearPlayAgricolaCardID() {
	m.play_agricola_card_id = nil
	m.clearedFields[card.FieldPlayAgricolaCardID] = struct{}{}
}

// PlayAgricolaCardIDCleared returns if the "play_agricola_card_id" field was cleared in this mutation.
func (m *CardMutation) PlayAgricolaCardIDCleared() bool {
	_, ok := m.clearedFields[card.FieldPlayAgricolaCardID]
	return ok
}

// ResetPlayAgricolaCardID resets all changes to the "play_agricola_card_id" field.
func (m *CardMutation) ResetPlayAgricolaCardID() {
	m.play_agricola_card_id = nil
	delete(m.clearedFields, card.FieldPlayAgricolaCardID)
}

// SetDeckID sets the "deck_id" field.
func (m *CardMutation) SetDeckID(i int) {
	m.deck = &i
}

// DeckID returns the value of the "deck_id" field in the mutation.
func (m *CardMutation) DeckID() (r int, exists bool) {
	v := m.deck
	if v == nil {
		return
	}
	return *v, true
}

// OldDeckID returns the old "deck_id" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldDeckID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeckID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeckID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeckID: %w", err)
	}
	return oldValue.DeckID, nil
}

// ClearDeckID clears the value of the "deck_id" field.
func (m *CardMutation) ClearDeckID() {
	m.deck = nil
	m.clearedFields[card.FieldDeckID] = struct{}{}
}

// DeckIDCleared returns if the "deck_id" field was cleared in this mutation.
func (m *CardMutation) DeckIDCleared() bool {
	_, ok := m.clearedFields[card.FieldDeckID]
	return ok
}

// ResetDeckID resets all changes to the "deck_id" field.
func (m *CardMutation) ResetDeckID() {
	m.deck = nil
	delete(m.clearedFields, card.FieldDeckID)
}

// SetCardTypeID sets the "card_type_id" field.
func (m *CardMutation) SetCardTypeID(i int) {
	m.card_type = &i
}

// CardTypeID returns the value of the "card_type_id" field in the mutation.
func (m *CardMutation) CardTypeID() (r int, exists bool) {
	v := m.card_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCardTypeID returns the old "card_type_id" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldCardTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCardTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCardTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardTypeID: %w", err)
	}
	return oldValue.CardTypeID, nil
}

// ResetCardTypeID resets all changes to the "card_type_id" field.
func (m *CardMutation) ResetCardTypeID() {
	m.card_type = nil
}

// SetCardSpecialColorID sets the "card_special_color_id" field.
func (m *CardMutation) SetCardSpecialColorID(i int) {
	m.card_special_color = &i
}

// CardSpecialColorID returns the value of the "card_special_color_id" field in the mutation.
func (m *CardMutation) CardSpecialColorID() (r int, exists bool) {
	v := m.card_special_color
	if v == nil {
		return
	}
	return *v, true
}

// OldCardSpecialColorID returns the old "card_special_color_id" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldCardSpecialColorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCardSpecialColorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCardSpecialColorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardSpecialColorID: %w", err)
	}
	return oldValue.CardSpecialColorID, nil
}

// ClearCardSpecialColorID clears the value of the "card_special_color_id" field.
func (m *CardMutation) ClearCardSpecialColorID() {
	m.card_special_color = nil
	m.clearedFields[card.FieldCardSpecialColorID] = struct{}{}
}

// CardSpecialColorIDCleared returns if the "card_special_color_id" field was cleared in this mutation.
func (m *CardMutation) CardSpecialColorIDCleared() bool {
	_, ok := m.clearedFields[card.FieldCardSpecialColorID]
	return ok
}

// ResetCardSpecialColorID resets all changes to the "card_special_color_id" field.
func (m *CardMutation) ResetCardSpecialColorID() {
	m.card_special_color = nil
	delete(m.clearedFields, card.FieldCardSpecialColorID)
}

// SetNameJa sets the "name_ja" field.
func (m *CardMutation) SetNameJa(s string) {
	m.name_ja = &s
}

// NameJa returns the value of the "name_ja" field in the mutation.
func (m *CardMutation) NameJa() (r string, exists bool) {
	v := m.name_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJa returns the old "name_ja" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldNameJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJa: %w", err)
	}
	return oldValue.NameJa, nil
}

// ClearNameJa clears the value of the "name_ja" field.
func (m *CardMutation) ClearNameJa() {
	m.name_ja = nil
	m.clearedFields[card.FieldNameJa] = struct{}{}
}

// NameJaCleared returns if the "name_ja" field was cleared in this mutation.
func (m *CardMutation) NameJaCleared() bool {
	_, ok := m.clearedFields[card.FieldNameJa]
	return ok
}

// ResetNameJa resets all changes to the "name_ja" field.
func (m *CardMutation) ResetNameJa() {
	m.name_ja = nil
	delete(m.clearedFields, card.FieldNameJa)
}

// SetNameEn sets the "name_en" field.
func (m *CardMutation) SetNameEn(s string) {
	m.name_en = &s
}

// NameEn returns the value of the "name_en" field in the mutation.
func (m *CardMutation) NameEn() (r string, exists bool) {
	v := m.name_en
	if v == nil {
		return
	}
	return *v, true
}

// OldNameEn returns the old "name_en" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldNameEn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameEn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameEn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameEn: %w", err)
	}
	return oldValue.NameEn, nil
}

// ClearNameEn clears the value of the "name_en" field.
func (m *CardMutation) ClearNameEn() {
	m.name_en = nil
	m.clearedFields[card.FieldNameEn] = struct{}{}
}

// NameEnCleared returns if the "name_en" field was cleared in this mutation.
func (m *CardMutation) NameEnCleared() bool {
	_, ok := m.clearedFields[card.FieldNameEn]
	return ok
}

// ResetNameEn resets all changes to the "name_en" field.
func (m *CardMutation) ResetNameEn() {
	m.name_en = nil
	delete(m.clearedFields, card.FieldNameEn)
}

// SetMinPlayersNumber sets the "min_players_number" field.
func (m *CardMutation) SetMinPlayersNumber(i int) {
	m.min_players_number = &i
	m.addmin_players_number = nil
}

// MinPlayersNumber returns the value of the "min_players_number" field in the mutation.
func (m *CardMutation) MinPlayersNumber() (r int, exists bool) {
	v := m.min_players_number
	if v == nil {
		return
	}
	return *v, true
}

// OldMinPlayersNumber returns the old "min_players_number" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldMinPlayersNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinPlayersNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinPlayersNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinPlayersNumber: %w", err)
	}
	return oldValue.MinPlayersNumber, nil
}

// AddMinPlayersNumber adds i to the "min_players_number" field.
func (m *CardMutation) AddMinPlayersNumber(i int) {
	if m.addmin_players_number != nil {
		*m.addmin_players_number += i
	} else {
		m.addmin_players_number = &i
	}
}

// AddedMinPlayersNumber returns the value that was added to the "min_players_number" field in this mutation.
func (m *CardMutation) AddedMinPlayersNumber() (r int, exists bool) {
	v := m.addmin_players_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinPlayersNumber clears the value of the "min_players_number" field.
func (m *CardMutation) ClearMinPlayersNumber() {
	m.min_players_number = nil
	m.addmin_players_number = nil
	m.clearedFields[card.FieldMinPlayersNumber] = struct{}{}
}

// MinPlayersNumberCleared returns if the "min_players_number" field was cleared in this mutation.
func (m *CardMutation) MinPlayersNumberCleared() bool {
	_, ok := m.clearedFields[card.FieldMinPlayersNumber]
	return ok
}

// ResetMinPlayersNumber resets all changes to the "min_players_number" field.
func (m *CardMutation) ResetMinPlayersNumber() {
	m.min_players_number = nil
	m.addmin_players_number = nil
	delete(m.clearedFields, card.FieldMinPlayersNumber)
}

// SetPrerequisite sets the "prerequisite" field.
func (m *CardMutation) SetPrerequisite(s string) {
	m.prerequisite = &s
}

// Prerequisite returns the value of the "prerequisite" field in the mutation.
func (m *CardMutation) Prerequisite() (r string, exists bool) {
	v := m.prerequisite
	if v == nil {
		return
	}
	return *v, true
}

// OldPrerequisite returns the old "prerequisite" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldPrerequisite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrerequisite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrerequisite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrerequisite: %w", err)
	}
	return oldValue.Prerequisite, nil
}

// ClearPrerequisite clears the value of the "prerequisite" field.
func (m *CardMutation) ClearPrerequisite() {
	m.prerequisite = nil
	m.clearedFields[card.FieldPrerequisite] = struct{}{}
}

// PrerequisiteCleared returns if the "prerequisite" field was cleared in this mutation.
func (m *CardMutation) PrerequisiteCleared() bool {
	_, ok := m.clearedFields[card.FieldPrerequisite]
	return ok
}

// ResetPrerequisite resets all changes to the "prerequisite" field.
func (m *CardMutation) ResetPrerequisite() {
	m.prerequisite = nil
	delete(m.clearedFields, card.FieldPrerequisite)
}

// SetCost sets the "cost" field.
func (m *CardMutation) SetCost(s string) {
	m.cost = &s
}

// Cost returns the value of the "cost" field in the mutation.
func (m *CardMutation) Cost() (r string, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old "cost" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldCost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// ClearCost clears the value of the "cost" field.
func (m *CardMutation) ClearCost() {
	m.cost = nil
	m.clearedFields[card.FieldCost] = struct{}{}
}

// CostCleared returns if the "cost" field was cleared in this mutation.
func (m *CardMutation) CostCleared() bool {
	_, ok := m.clearedFields[card.FieldCost]
	return ok
}

// ResetCost resets all changes to the "cost" field.
func (m *CardMutation) ResetCost() {
	m.cost = nil
	delete(m.clearedFields, card.FieldCost)
}

// SetDescription sets the "description" field.
func (m *CardMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CardMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CardMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[card.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CardMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[card.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CardMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, card.FieldDescription)
}

// SetIsOfficialJa sets the "is_official_ja" field.
func (m *CardMutation) SetIsOfficialJa(b bool) {
	m.is_official_ja = &b
}

// IsOfficialJa returns the value of the "is_official_ja" field in the mutation.
func (m *CardMutation) IsOfficialJa() (r bool, exists bool) {
	v := m.is_official_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOfficialJa returns the old "is_official_ja" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldIsOfficialJa(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOfficialJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOfficialJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOfficialJa: %w", err)
	}
	return oldValue.IsOfficialJa, nil
}

// ResetIsOfficialJa resets all changes to the "is_official_ja" field.
func (m *CardMutation) ResetIsOfficialJa() {
	m.is_official_ja = nil
}

// SetVictoryPoint sets the "victory_point" field.
func (m *CardMutation) SetVictoryPoint(i int) {
	m.victory_point = &i
	m.addvictory_point = nil
}

// VictoryPoint returns the value of the "victory_point" field in the mutation.
func (m *CardMutation) VictoryPoint() (r int, exists bool) {
	v := m.victory_point
	if v == nil {
		return
	}
	return *v, true
}

// OldVictoryPoint returns the old "victory_point" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldVictoryPoint(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVictoryPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVictoryPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVictoryPoint: %w", err)
	}
	return oldValue.VictoryPoint, nil
}

// AddVictoryPoint adds i to the "victory_point" field.
func (m *CardMutation) AddVictoryPoint(i int) {
	if m.addvictory_point != nil {
		*m.addvictory_point += i
	} else {
		m.addvictory_point = &i
	}
}

// AddedVictoryPoint returns the value that was added to the "victory_point" field in this mutation.
func (m *CardMutation) AddedVictoryPoint() (r int, exists bool) {
	v := m.addvictory_point
	if v == nil {
		return
	}
	return *v, true
}

// ClearVictoryPoint clears the value of the "victory_point" field.
func (m *CardMutation) ClearVictoryPoint() {
	m.victory_point = nil
	m.addvictory_point = nil
	m.clearedFields[card.FieldVictoryPoint] = struct{}{}
}

// VictoryPointCleared returns if the "victory_point" field was cleared in this mutation.
func (m *CardMutation) VictoryPointCleared() bool {
	_, ok := m.clearedFields[card.FieldVictoryPoint]
	return ok
}

// ResetVictoryPoint resets all changes to the "victory_point" field.
func (m *CardMutation) ResetVictoryPoint() {
	m.victory_point = nil
	m.addvictory_point = nil
	delete(m.clearedFields, card.FieldVictoryPoint)
}

// SetSpecialVictoryPoint sets the "special_victory_point" field.
func (m *CardMutation) SetSpecialVictoryPoint(s string) {
	m.special_victory_point = &s
}

// SpecialVictoryPoint returns the value of the "special_victory_point" field in the mutation.
func (m *CardMutation) SpecialVictoryPoint() (r string, exists bool) {
	v := m.special_victory_point
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialVictoryPoint returns the old "special_victory_point" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldSpecialVictoryPoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecialVictoryPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecialVictoryPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialVictoryPoint: %w", err)
	}
	return oldValue.SpecialVictoryPoint, nil
}

// ClearSpecialVictoryPoint clears the value of the "special_victory_point" field.
func (m *CardMutation) ClearSpecialVictoryPoint() {
	m.special_victory_point = nil
	m.clearedFields[card.FieldSpecialVictoryPoint] = struct{}{}
}

// SpecialVictoryPointCleared returns if the "special_victory_point" field was cleared in this mutation.
func (m *CardMutation) SpecialVictoryPointCleared() bool {
	_, ok := m.clearedFields[card.FieldSpecialVictoryPoint]
	return ok
}

// ResetSpecialVictoryPoint resets all changes to the "special_victory_point" field.
func (m *CardMutation) ResetSpecialVictoryPoint() {
	m.special_victory_point = nil
	delete(m.clearedFields, card.FieldSpecialVictoryPoint)
}

// SetHasArrrow sets the "has_arrrow" field.
func (m *CardMutation) SetHasArrrow(b bool) {
	m.has_arrrow = &b
}

// HasArrrow returns the value of the "has_arrrow" field in the mutation.
func (m *CardMutation) HasArrrow() (r bool, exists bool) {
	v := m.has_arrrow
	if v == nil {
		return
	}
	return *v, true
}

// OldHasArrrow returns the old "has_arrrow" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldHasArrrow(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasArrrow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasArrrow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasArrrow: %w", err)
	}
	return oldValue.HasArrrow, nil
}

// ResetHasArrrow resets all changes to the "has_arrrow" field.
func (m *CardMutation) ResetHasArrrow() {
	m.has_arrrow = nil
}

// SetHasBonusPointIcon sets the "has_bonus_point_icon" field.
func (m *CardMutation) SetHasBonusPointIcon(b bool) {
	m.has_bonus_point_icon = &b
}

// HasBonusPointIcon returns the value of the "has_bonus_point_icon" field in the mutation.
func (m *CardMutation) HasBonusPointIcon() (r bool, exists bool) {
	v := m.has_bonus_point_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldHasBonusPointIcon returns the old "has_bonus_point_icon" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldHasBonusPointIcon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasBonusPointIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasBonusPointIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasBonusPointIcon: %w", err)
	}
	return oldValue.HasBonusPointIcon, nil
}

// ResetHasBonusPointIcon resets all changes to the "has_bonus_point_icon" field.
func (m *CardMutation) ResetHasBonusPointIcon() {
	m.has_bonus_point_icon = nil
}

// SetHasNegativeBonusPointIcon sets the "has_negative_bonus_point_icon" field.
func (m *CardMutation) SetHasNegativeBonusPointIcon(b bool) {
	m.has_negative_bonus_point_icon = &b
}

// HasNegativeBonusPointIcon returns the value of the "has_negative_bonus_point_icon" field in the mutation.
func (m *CardMutation) HasNegativeBonusPointIcon() (r bool, exists bool) {
	v := m.has_negative_bonus_point_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldHasNegativeBonusPointIcon returns the old "has_negative_bonus_point_icon" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldHasNegativeBonusPointIcon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasNegativeBonusPointIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasNegativeBonusPointIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasNegativeBonusPointIcon: %w", err)
	}
	return oldValue.HasNegativeBonusPointIcon, nil
}

// ResetHasNegativeBonusPointIcon resets all changes to the "has_negative_bonus_point_icon" field.
func (m *CardMutation) ResetHasNegativeBonusPointIcon() {
	m.has_negative_bonus_point_icon = nil
}

// SetHasPanIcon sets the "has_pan_icon" field.
func (m *CardMutation) SetHasPanIcon(b bool) {
	m.has_pan_icon = &b
}

// HasPanIcon returns the value of the "has_pan_icon" field in the mutation.
func (m *CardMutation) HasPanIcon() (r bool, exists bool) {
	v := m.has_pan_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldHasPanIcon returns the old "has_pan_icon" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldHasPanIcon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasPanIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasPanIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasPanIcon: %w", err)
	}
	return oldValue.HasPanIcon, nil
}

// ResetHasPanIcon resets all changes to the "has_pan_icon" field.
func (m *CardMutation) ResetHasPanIcon() {
	m.has_pan_icon = nil
}

// SetHasBreadIcon sets the "has_bread_icon" field.
func (m *CardMutation) SetHasBreadIcon(b bool) {
	m.has_bread_icon = &b
}

// HasBreadIcon returns the value of the "has_bread_icon" field in the mutation.
func (m *CardMutation) HasBreadIcon() (r bool, exists bool) {
	v := m.has_bread_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldHasBreadIcon returns the old "has_bread_icon" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldHasBreadIcon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasBreadIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasBreadIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasBreadIcon: %w", err)
	}
	return oldValue.HasBreadIcon, nil
}

// ResetHasBreadIcon resets all changes to the "has_bread_icon" field.
func (m *CardMutation) ResetHasBreadIcon() {
	m.has_bread_icon = nil
}

// SetHasFarmPlannerIcon sets the "has_farm_planner_icon" field.
func (m *CardMutation) SetHasFarmPlannerIcon(b bool) {
	m.has_farm_planner_icon = &b
}

// HasFarmPlannerIcon returns the value of the "has_farm_planner_icon" field in the mutation.
func (m *CardMutation) HasFarmPlannerIcon() (r bool, exists bool) {
	v := m.has_farm_planner_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldHasFarmPlannerIcon returns the old "has_farm_planner_icon" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldHasFarmPlannerIcon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasFarmPlannerIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasFarmPlannerIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasFarmPlannerIcon: %w", err)
	}
	return oldValue.HasFarmPlannerIcon, nil
}

// ResetHasFarmPlannerIcon resets all changes to the "has_farm_planner_icon" field.
func (m *CardMutation) ResetHasFarmPlannerIcon() {
	m.has_farm_planner_icon = nil
}

// SetHasActionsBoosterIcon sets the "has_actions_booster_icon" field.
func (m *CardMutation) SetHasActionsBoosterIcon(b bool) {
	m.has_actions_booster_icon = &b
}

// HasActionsBoosterIcon returns the value of the "has_actions_booster_icon" field in the mutation.
func (m *CardMutation) HasActionsBoosterIcon() (r bool, exists bool) {
	v := m.has_actions_booster_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldHasActionsBoosterIcon returns the old "has_actions_booster_icon" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldHasActionsBoosterIcon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasActionsBoosterIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasActionsBoosterIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasActionsBoosterIcon: %w", err)
	}
	return oldValue.HasActionsBoosterIcon, nil
}

// ResetHasActionsBoosterIcon resets all changes to the "has_actions_booster_icon" field.
func (m *CardMutation) ResetHasActionsBoosterIcon() {
	m.has_actions_booster_icon = nil
}

// SetHasPointsProviderIcon sets the "has_points_provider_icon" field.
func (m *CardMutation) SetHasPointsProviderIcon(b bool) {
	m.has_points_provider_icon = &b
}

// HasPointsProviderIcon returns the value of the "has_points_provider_icon" field in the mutation.
func (m *CardMutation) HasPointsProviderIcon() (r bool, exists bool) {
	v := m.has_points_provider_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldHasPointsProviderIcon returns the old "has_points_provider_icon" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldHasPointsProviderIcon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasPointsProviderIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasPointsProviderIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasPointsProviderIcon: %w", err)
	}
	return oldValue.HasPointsProviderIcon, nil
}

// ResetHasPointsProviderIcon resets all changes to the "has_points_provider_icon" field.
func (m *CardMutation) ResetHasPointsProviderIcon() {
	m.has_points_provider_icon = nil
}

// SetHasGoodsProviderIcon sets the "has_goods_provider_icon" field.
func (m *CardMutation) SetHasGoodsProviderIcon(b bool) {
	m.has_goods_provider_icon = &b
}

// HasGoodsProviderIcon returns the value of the "has_goods_provider_icon" field in the mutation.
func (m *CardMutation) HasGoodsProviderIcon() (r bool, exists bool) {
	v := m.has_goods_provider_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldHasGoodsProviderIcon returns the old "has_goods_provider_icon" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldHasGoodsProviderIcon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasGoodsProviderIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasGoodsProviderIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasGoodsProviderIcon: %w", err)
	}
	return oldValue.HasGoodsProviderIcon, nil
}

// ResetHasGoodsProviderIcon resets all changes to the "has_goods_provider_icon" field.
func (m *CardMutation) ResetHasGoodsProviderIcon() {
	m.has_goods_provider_icon = nil
}

// SetHasFoodProviderIcon sets the "has_food_provider_icon" field.
func (m *CardMutation) SetHasFoodProviderIcon(b bool) {
	m.has_food_provider_icon = &b
}

// HasFoodProviderIcon returns the value of the "has_food_provider_icon" field in the mutation.
func (m *CardMutation) HasFoodProviderIcon() (r bool, exists bool) {
	v := m.has_food_provider_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldHasFoodProviderIcon returns the old "has_food_provider_icon" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldHasFoodProviderIcon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasFoodProviderIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasFoodProviderIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasFoodProviderIcon: %w", err)
	}
	return oldValue.HasFoodProviderIcon, nil
}

// ResetHasFoodProviderIcon resets all changes to the "has_food_provider_icon" field.
func (m *CardMutation) ResetHasFoodProviderIcon() {
	m.has_food_provider_icon = nil
}

// SetHasCropProviderIcon sets the "has_crop_provider_icon" field.
func (m *CardMutation) SetHasCropProviderIcon(b bool) {
	m.has_crop_provider_icon = &b
}

// HasCropProviderIcon returns the value of the "has_crop_provider_icon" field in the mutation.
func (m *CardMutation) HasCropProviderIcon() (r bool, exists bool) {
	v := m.has_crop_provider_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldHasCropProviderIcon returns the old "has_crop_provider_icon" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldHasCropProviderIcon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasCropProviderIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasCropProviderIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasCropProviderIcon: %w", err)
	}
	return oldValue.HasCropProviderIcon, nil
}

// ResetHasCropProviderIcon resets all changes to the "has_crop_provider_icon" field.
func (m *CardMutation) ResetHasCropProviderIcon() {
	m.has_crop_provider_icon = nil
}

// SetHasBuildingResourceProviderIcon sets the "has_building_resource_provider_icon" field.
func (m *CardMutation) SetHasBuildingResourceProviderIcon(b bool) {
	m.has_building_resource_provider_icon = &b
}

// HasBuildingResourceProviderIcon returns the value of the "has_building_resource_provider_icon" field in the mutation.
func (m *CardMutation) HasBuildingResourceProviderIcon() (r bool, exists bool) {
	v := m.has_building_resource_provider_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldHasBuildingResourceProviderIcon returns the old "has_building_resource_provider_icon" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldHasBuildingResourceProviderIcon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasBuildingResourceProviderIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasBuildingResourceProviderIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasBuildingResourceProviderIcon: %w", err)
	}
	return oldValue.HasBuildingResourceProviderIcon, nil
}

// ResetHasBuildingResourceProviderIcon resets all changes to the "has_building_resource_provider_icon" field.
func (m *CardMutation) ResetHasBuildingResourceProviderIcon() {
	m.has_building_resource_provider_icon = nil
}

// SetHasLivestockProviderIcon sets the "has_livestock_provider_icon" field.
func (m *CardMutation) SetHasLivestockProviderIcon(b bool) {
	m.has_livestock_provider_icon = &b
}

// HasLivestockProviderIcon returns the value of the "has_livestock_provider_icon" field in the mutation.
func (m *CardMutation) HasLivestockProviderIcon() (r bool, exists bool) {
	v := m.has_livestock_provider_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldHasLivestockProviderIcon returns the old "has_livestock_provider_icon" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldHasLivestockProviderIcon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasLivestockProviderIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasLivestockProviderIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasLivestockProviderIcon: %w", err)
	}
	return oldValue.HasLivestockProviderIcon, nil
}

// ResetHasLivestockProviderIcon resets all changes to the "has_livestock_provider_icon" field.
func (m *CardMutation) ResetHasLivestockProviderIcon() {
	m.has_livestock_provider_icon = nil
}

// SetHasCutPeatIcon sets the "has_cut_peat_icon" field.
func (m *CardMutation) SetHasCutPeatIcon(b bool) {
	m.has_cut_peat_icon = &b
}

// HasCutPeatIcon returns the value of the "has_cut_peat_icon" field in the mutation.
func (m *CardMutation) HasCutPeatIcon() (r bool, exists bool) {
	v := m.has_cut_peat_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldHasCutPeatIcon returns the old "has_cut_peat_icon" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldHasCutPeatIcon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasCutPeatIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasCutPeatIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasCutPeatIcon: %w", err)
	}
	return oldValue.HasCutPeatIcon, nil
}

// ResetHasCutPeatIcon resets all changes to the "has_cut_peat_icon" field.
func (m *CardMutation) ResetHasCutPeatIcon() {
	m.has_cut_peat_icon = nil
}

// SetHasFellTreesIcon sets the "has_fell_trees_icon" field.
func (m *CardMutation) SetHasFellTreesIcon(b bool) {
	m.has_fell_trees_icon = &b
}

// HasFellTreesIcon returns the value of the "has_fell_trees_icon" field in the mutation.
func (m *CardMutation) HasFellTreesIcon() (r bool, exists bool) {
	v := m.has_fell_trees_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldHasFellTreesIcon returns the old "has_fell_trees_icon" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldHasFellTreesIcon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasFellTreesIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasFellTreesIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasFellTreesIcon: %w", err)
	}
	return oldValue.HasFellTreesIcon, nil
}

// ResetHasFellTreesIcon resets all changes to the "has_fell_trees_icon" field.
func (m *CardMutation) ResetHasFellTreesIcon() {
	m.has_fell_trees_icon = nil
}

// SetHasSlashAndBurnIcon sets the "has_slash_and_burn_icon" field.
func (m *CardMutation) SetHasSlashAndBurnIcon(b bool) {
	m.has_slash_and_burn_icon = &b
}

// HasSlashAndBurnIcon returns the value of the "has_slash_and_burn_icon" field in the mutation.
func (m *CardMutation) HasSlashAndBurnIcon() (r bool, exists bool) {
	v := m.has_slash_and_burn_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldHasSlashAndBurnIcon returns the old "has_slash_and_burn_icon" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldHasSlashAndBurnIcon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasSlashAndBurnIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasSlashAndBurnIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasSlashAndBurnIcon: %w", err)
	}
	return oldValue.HasSlashAndBurnIcon, nil
}

// ResetHasSlashAndBurnIcon resets all changes to the "has_slash_and_burn_icon" field.
func (m *CardMutation) ResetHasSlashAndBurnIcon() {
	m.has_slash_and_burn_icon = nil
}

// SetHasHiringFareIcon sets the "has_hiring_fare_icon" field.
func (m *CardMutation) SetHasHiringFareIcon(b bool) {
	m.has_hiring_fare_icon = &b
}

// HasHiringFareIcon returns the value of the "has_hiring_fare_icon" field in the mutation.
func (m *CardMutation) HasHiringFareIcon() (r bool, exists bool) {
	v := m.has_hiring_fare_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldHasHiringFareIcon returns the old "has_hiring_fare_icon" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldHasHiringFareIcon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasHiringFareIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasHiringFareIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasHiringFareIcon: %w", err)
	}
	return oldValue.HasHiringFareIcon, nil
}

// ResetHasHiringFareIcon resets all changes to the "has_hiring_fare_icon" field.
func (m *CardMutation) ResetHasHiringFareIcon() {
	m.has_hiring_fare_icon = nil
}

// ClearRevision clears the "revision" edge to the Revision entity.
func (m *CardMutation) ClearRevision() {
	m.clearedrevision = true
}

// RevisionCleared reports if the "revision" edge to the Revision entity was cleared.
func (m *CardMutation) RevisionCleared() bool {
	return m.clearedrevision
}

// RevisionIDs returns the "revision" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RevisionID instead. It exists only for internal usage by the builders.
func (m *CardMutation) RevisionIDs() (ids []int) {
	if id := m.revision; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRevision resets all changes to the "revision" edge.
func (m *CardMutation) ResetRevision() {
	m.revision = nil
	m.clearedrevision = false
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *CardMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *CardMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *CardMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *CardMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *CardMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *CardMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *CardMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// ClearDeck clears the "deck" edge to the Deck entity.
func (m *CardMutation) ClearDeck() {
	m.cleareddeck = true
}

// DeckCleared reports if the "deck" edge to the Deck entity was cleared.
func (m *CardMutation) DeckCleared() bool {
	return m.DeckIDCleared() || m.cleareddeck
}

// DeckIDs returns the "deck" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeckID instead. It exists only for internal usage by the builders.
func (m *CardMutation) DeckIDs() (ids []int) {
	if id := m.deck; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeck resets all changes to the "deck" edge.
func (m *CardMutation) ResetDeck() {
	m.deck = nil
	m.cleareddeck = false
}

// ClearCardType clears the "card_type" edge to the CardType entity.
func (m *CardMutation) ClearCardType() {
	m.clearedcard_type = true
}

// CardTypeCleared reports if the "card_type" edge to the CardType entity was cleared.
func (m *CardMutation) CardTypeCleared() bool {
	return m.clearedcard_type
}

// CardTypeIDs returns the "card_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CardTypeID instead. It exists only for internal usage by the builders.
func (m *CardMutation) CardTypeIDs() (ids []int) {
	if id := m.card_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCardType resets all changes to the "card_type" edge.
func (m *CardMutation) ResetCardType() {
	m.card_type = nil
	m.clearedcard_type = false
}

// ClearCardSpecialColor clears the "card_special_color" edge to the CardSpecialColor entity.
func (m *CardMutation) ClearCardSpecialColor() {
	m.clearedcard_special_color = true
}

// CardSpecialColorCleared reports if the "card_special_color" edge to the CardSpecialColor entity was cleared.
func (m *CardMutation) CardSpecialColorCleared() bool {
	return m.CardSpecialColorIDCleared() || m.clearedcard_special_color
}

// CardSpecialColorIDs returns the "card_special_color" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CardSpecialColorID instead. It exists only for internal usage by the builders.
func (m *CardMutation) CardSpecialColorIDs() (ids []int) {
	if id := m.card_special_color; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCardSpecialColor resets all changes to the "card_special_color" edge.
func (m *CardMutation) ResetCardSpecialColor() {
	m.card_special_color = nil
	m.clearedcard_special_color = false
}

// AddChildIDs adds the "children" edge to the Card entity by ids.
func (m *CardMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Card entity.
func (m *CardMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Card entity was cleared.
func (m *CardMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Card entity by IDs.
func (m *CardMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Card entity.
func (m *CardMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CardMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CardMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddAncestorIDs adds the "ancestors" edge to the Card entity by ids.
func (m *CardMutation) AddAncestorIDs(ids ...int) {
	if m.ancestors == nil {
		m.ancestors = make(map[int]struct{})
	}
	for i := range ids {
		m.ancestors[ids[i]] = struct{}{}
	}
}

// ClearAncestors clears the "ancestors" edge to the Card entity.
func (m *CardMutation) ClearAncestors() {
	m.clearedancestors = true
}

// AncestorsCleared reports if the "ancestors" edge to the Card entity was cleared.
func (m *CardMutation) AncestorsCleared() bool {
	return m.clearedancestors
}

// RemoveAncestorIDs removes the "ancestors" edge to the Card entity by IDs.
func (m *CardMutation) RemoveAncestorIDs(ids ...int) {
	if m.removedancestors == nil {
		m.removedancestors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ancestors, ids[i])
		m.removedancestors[ids[i]] = struct{}{}
	}
}

// RemovedAncestors returns the removed IDs of the "ancestors" edge to the Card entity.
func (m *CardMutation) RemovedAncestorsIDs() (ids []int) {
	for id := range m.removedancestors {
		ids = append(ids, id)
	}
	return
}

// AncestorsIDs returns the "ancestors" edge IDs in the mutation.
func (m *CardMutation) AncestorsIDs() (ids []int) {
	for id := range m.ancestors {
		ids = append(ids, id)
	}
	return
}

// ResetAncestors resets all changes to the "ancestors" edge.
func (m *CardMutation) ResetAncestors() {
	m.ancestors = nil
	m.clearedancestors = false
	m.removedancestors = nil
}

// Where appends a list predicates to the CardMutation builder.
func (m *CardMutation) Where(ps ...predicate.Card) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CardMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Card).
func (m *CardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CardMutation) Fields() []string {
	fields := make([]string, 0, 33)
	if m.literal_id != nil {
		fields = append(fields, card.FieldLiteralID)
	}
	if m.revision != nil {
		fields = append(fields, card.FieldRevisionID)
	}
	if m.printed_id != nil {
		fields = append(fields, card.FieldPrintedID)
	}
	if m.play_agricola_card_id != nil {
		fields = append(fields, card.FieldPlayAgricolaCardID)
	}
	if m.deck != nil {
		fields = append(fields, card.FieldDeckID)
	}
	if m.card_type != nil {
		fields = append(fields, card.FieldCardTypeID)
	}
	if m.card_special_color != nil {
		fields = append(fields, card.FieldCardSpecialColorID)
	}
	if m.name_ja != nil {
		fields = append(fields, card.FieldNameJa)
	}
	if m.name_en != nil {
		fields = append(fields, card.FieldNameEn)
	}
	if m.min_players_number != nil {
		fields = append(fields, card.FieldMinPlayersNumber)
	}
	if m.prerequisite != nil {
		fields = append(fields, card.FieldPrerequisite)
	}
	if m.cost != nil {
		fields = append(fields, card.FieldCost)
	}
	if m.description != nil {
		fields = append(fields, card.FieldDescription)
	}
	if m.is_official_ja != nil {
		fields = append(fields, card.FieldIsOfficialJa)
	}
	if m.victory_point != nil {
		fields = append(fields, card.FieldVictoryPoint)
	}
	if m.special_victory_point != nil {
		fields = append(fields, card.FieldSpecialVictoryPoint)
	}
	if m.has_arrrow != nil {
		fields = append(fields, card.FieldHasArrrow)
	}
	if m.has_bonus_point_icon != nil {
		fields = append(fields, card.FieldHasBonusPointIcon)
	}
	if m.has_negative_bonus_point_icon != nil {
		fields = append(fields, card.FieldHasNegativeBonusPointIcon)
	}
	if m.has_pan_icon != nil {
		fields = append(fields, card.FieldHasPanIcon)
	}
	if m.has_bread_icon != nil {
		fields = append(fields, card.FieldHasBreadIcon)
	}
	if m.has_farm_planner_icon != nil {
		fields = append(fields, card.FieldHasFarmPlannerIcon)
	}
	if m.has_actions_booster_icon != nil {
		fields = append(fields, card.FieldHasActionsBoosterIcon)
	}
	if m.has_points_provider_icon != nil {
		fields = append(fields, card.FieldHasPointsProviderIcon)
	}
	if m.has_goods_provider_icon != nil {
		fields = append(fields, card.FieldHasGoodsProviderIcon)
	}
	if m.has_food_provider_icon != nil {
		fields = append(fields, card.FieldHasFoodProviderIcon)
	}
	if m.has_crop_provider_icon != nil {
		fields = append(fields, card.FieldHasCropProviderIcon)
	}
	if m.has_building_resource_provider_icon != nil {
		fields = append(fields, card.FieldHasBuildingResourceProviderIcon)
	}
	if m.has_livestock_provider_icon != nil {
		fields = append(fields, card.FieldHasLivestockProviderIcon)
	}
	if m.has_cut_peat_icon != nil {
		fields = append(fields, card.FieldHasCutPeatIcon)
	}
	if m.has_fell_trees_icon != nil {
		fields = append(fields, card.FieldHasFellTreesIcon)
	}
	if m.has_slash_and_burn_icon != nil {
		fields = append(fields, card.FieldHasSlashAndBurnIcon)
	}
	if m.has_hiring_fare_icon != nil {
		fields = append(fields, card.FieldHasHiringFareIcon)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case card.FieldLiteralID:
		return m.LiteralID()
	case card.FieldRevisionID:
		return m.RevisionID()
	case card.FieldPrintedID:
		return m.PrintedID()
	case card.FieldPlayAgricolaCardID:
		return m.PlayAgricolaCardID()
	case card.FieldDeckID:
		return m.DeckID()
	case card.FieldCardTypeID:
		return m.CardTypeID()
	case card.FieldCardSpecialColorID:
		return m.CardSpecialColorID()
	case card.FieldNameJa:
		return m.NameJa()
	case card.FieldNameEn:
		return m.NameEn()
	case card.FieldMinPlayersNumber:
		return m.MinPlayersNumber()
	case card.FieldPrerequisite:
		return m.Prerequisite()
	case card.FieldCost:
		return m.Cost()
	case card.FieldDescription:
		return m.Description()
	case card.FieldIsOfficialJa:
		return m.IsOfficialJa()
	case card.FieldVictoryPoint:
		return m.VictoryPoint()
	case card.FieldSpecialVictoryPoint:
		return m.SpecialVictoryPoint()
	case card.FieldHasArrrow:
		return m.HasArrrow()
	case card.FieldHasBonusPointIcon:
		return m.HasBonusPointIcon()
	case card.FieldHasNegativeBonusPointIcon:
		return m.HasNegativeBonusPointIcon()
	case card.FieldHasPanIcon:
		return m.HasPanIcon()
	case card.FieldHasBreadIcon:
		return m.HasBreadIcon()
	case card.FieldHasFarmPlannerIcon:
		return m.HasFarmPlannerIcon()
	case card.FieldHasActionsBoosterIcon:
		return m.HasActionsBoosterIcon()
	case card.FieldHasPointsProviderIcon:
		return m.HasPointsProviderIcon()
	case card.FieldHasGoodsProviderIcon:
		return m.HasGoodsProviderIcon()
	case card.FieldHasFoodProviderIcon:
		return m.HasFoodProviderIcon()
	case card.FieldHasCropProviderIcon:
		return m.HasCropProviderIcon()
	case card.FieldHasBuildingResourceProviderIcon:
		return m.HasBuildingResourceProviderIcon()
	case card.FieldHasLivestockProviderIcon:
		return m.HasLivestockProviderIcon()
	case card.FieldHasCutPeatIcon:
		return m.HasCutPeatIcon()
	case card.FieldHasFellTreesIcon:
		return m.HasFellTreesIcon()
	case card.FieldHasSlashAndBurnIcon:
		return m.HasSlashAndBurnIcon()
	case card.FieldHasHiringFareIcon:
		return m.HasHiringFareIcon()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case card.FieldLiteralID:
		return m.OldLiteralID(ctx)
	case card.FieldRevisionID:
		return m.OldRevisionID(ctx)
	case card.FieldPrintedID:
		return m.OldPrintedID(ctx)
	case card.FieldPlayAgricolaCardID:
		return m.OldPlayAgricolaCardID(ctx)
	case card.FieldDeckID:
		return m.OldDeckID(ctx)
	case card.FieldCardTypeID:
		return m.OldCardTypeID(ctx)
	case card.FieldCardSpecialColorID:
		return m.OldCardSpecialColorID(ctx)
	case card.FieldNameJa:
		return m.OldNameJa(ctx)
	case card.FieldNameEn:
		return m.OldNameEn(ctx)
	case card.FieldMinPlayersNumber:
		return m.OldMinPlayersNumber(ctx)
	case card.FieldPrerequisite:
		return m.OldPrerequisite(ctx)
	case card.FieldCost:
		return m.OldCost(ctx)
	case card.FieldDescription:
		return m.OldDescription(ctx)
	case card.FieldIsOfficialJa:
		return m.OldIsOfficialJa(ctx)
	case card.FieldVictoryPoint:
		return m.OldVictoryPoint(ctx)
	case card.FieldSpecialVictoryPoint:
		return m.OldSpecialVictoryPoint(ctx)
	case card.FieldHasArrrow:
		return m.OldHasArrrow(ctx)
	case card.FieldHasBonusPointIcon:
		return m.OldHasBonusPointIcon(ctx)
	case card.FieldHasNegativeBonusPointIcon:
		return m.OldHasNegativeBonusPointIcon(ctx)
	case card.FieldHasPanIcon:
		return m.OldHasPanIcon(ctx)
	case card.FieldHasBreadIcon:
		return m.OldHasBreadIcon(ctx)
	case card.FieldHasFarmPlannerIcon:
		return m.OldHasFarmPlannerIcon(ctx)
	case card.FieldHasActionsBoosterIcon:
		return m.OldHasActionsBoosterIcon(ctx)
	case card.FieldHasPointsProviderIcon:
		return m.OldHasPointsProviderIcon(ctx)
	case card.FieldHasGoodsProviderIcon:
		return m.OldHasGoodsProviderIcon(ctx)
	case card.FieldHasFoodProviderIcon:
		return m.OldHasFoodProviderIcon(ctx)
	case card.FieldHasCropProviderIcon:
		return m.OldHasCropProviderIcon(ctx)
	case card.FieldHasBuildingResourceProviderIcon:
		return m.OldHasBuildingResourceProviderIcon(ctx)
	case card.FieldHasLivestockProviderIcon:
		return m.OldHasLivestockProviderIcon(ctx)
	case card.FieldHasCutPeatIcon:
		return m.OldHasCutPeatIcon(ctx)
	case card.FieldHasFellTreesIcon:
		return m.OldHasFellTreesIcon(ctx)
	case card.FieldHasSlashAndBurnIcon:
		return m.OldHasSlashAndBurnIcon(ctx)
	case card.FieldHasHiringFareIcon:
		return m.OldHasHiringFareIcon(ctx)
	}
	return nil, fmt.Errorf("unknown Card field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case card.FieldLiteralID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLiteralID(v)
		return nil
	case card.FieldRevisionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevisionID(v)
		return nil
	case card.FieldPrintedID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrintedID(v)
		return nil
	case card.FieldPlayAgricolaCardID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayAgricolaCardID(v)
		return nil
	case card.FieldDeckID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeckID(v)
		return nil
	case card.FieldCardTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardTypeID(v)
		return nil
	case card.FieldCardSpecialColorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardSpecialColorID(v)
		return nil
	case card.FieldNameJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJa(v)
		return nil
	case card.FieldNameEn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameEn(v)
		return nil
	case card.FieldMinPlayersNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinPlayersNumber(v)
		return nil
	case card.FieldPrerequisite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrerequisite(v)
		return nil
	case card.FieldCost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	case card.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case card.FieldIsOfficialJa:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOfficialJa(v)
		return nil
	case card.FieldVictoryPoint:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVictoryPoint(v)
		return nil
	case card.FieldSpecialVictoryPoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialVictoryPoint(v)
		return nil
	case card.FieldHasArrrow:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasArrrow(v)
		return nil
	case card.FieldHasBonusPointIcon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasBonusPointIcon(v)
		return nil
	case card.FieldHasNegativeBonusPointIcon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasNegativeBonusPointIcon(v)
		return nil
	case card.FieldHasPanIcon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasPanIcon(v)
		return nil
	case card.FieldHasBreadIcon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasBreadIcon(v)
		return nil
	case card.FieldHasFarmPlannerIcon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasFarmPlannerIcon(v)
		return nil
	case card.FieldHasActionsBoosterIcon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasActionsBoosterIcon(v)
		return nil
	case card.FieldHasPointsProviderIcon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasPointsProviderIcon(v)
		return nil
	case card.FieldHasGoodsProviderIcon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasGoodsProviderIcon(v)
		return nil
	case card.FieldHasFoodProviderIcon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasFoodProviderIcon(v)
		return nil
	case card.FieldHasCropProviderIcon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasCropProviderIcon(v)
		return nil
	case card.FieldHasBuildingResourceProviderIcon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasBuildingResourceProviderIcon(v)
		return nil
	case card.FieldHasLivestockProviderIcon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasLivestockProviderIcon(v)
		return nil
	case card.FieldHasCutPeatIcon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasCutPeatIcon(v)
		return nil
	case card.FieldHasFellTreesIcon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasFellTreesIcon(v)
		return nil
	case card.FieldHasSlashAndBurnIcon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasSlashAndBurnIcon(v)
		return nil
	case card.FieldHasHiringFareIcon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasHiringFareIcon(v)
		return nil
	}
	return fmt.Errorf("unknown Card field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CardMutation) AddedFields() []string {
	var fields []string
	if m.addmin_players_number != nil {
		fields = append(fields, card.FieldMinPlayersNumber)
	}
	if m.addvictory_point != nil {
		fields = append(fields, card.FieldVictoryPoint)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case card.FieldMinPlayersNumber:
		return m.AddedMinPlayersNumber()
	case card.FieldVictoryPoint:
		return m.AddedVictoryPoint()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case card.FieldMinPlayersNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinPlayersNumber(v)
		return nil
	case card.FieldVictoryPoint:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVictoryPoint(v)
		return nil
	}
	return fmt.Errorf("unknown Card numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(card.FieldPrintedID) {
		fields = append(fields, card.FieldPrintedID)
	}
	if m.FieldCleared(card.FieldPlayAgricolaCardID) {
		fields = append(fields, card.FieldPlayAgricolaCardID)
	}
	if m.FieldCleared(card.FieldDeckID) {
		fields = append(fields, card.FieldDeckID)
	}
	if m.FieldCleared(card.FieldCardSpecialColorID) {
		fields = append(fields, card.FieldCardSpecialColorID)
	}
	if m.FieldCleared(card.FieldNameJa) {
		fields = append(fields, card.FieldNameJa)
	}
	if m.FieldCleared(card.FieldNameEn) {
		fields = append(fields, card.FieldNameEn)
	}
	if m.FieldCleared(card.FieldMinPlayersNumber) {
		fields = append(fields, card.FieldMinPlayersNumber)
	}
	if m.FieldCleared(card.FieldPrerequisite) {
		fields = append(fields, card.FieldPrerequisite)
	}
	if m.FieldCleared(card.FieldCost) {
		fields = append(fields, card.FieldCost)
	}
	if m.FieldCleared(card.FieldDescription) {
		fields = append(fields, card.FieldDescription)
	}
	if m.FieldCleared(card.FieldVictoryPoint) {
		fields = append(fields, card.FieldVictoryPoint)
	}
	if m.FieldCleared(card.FieldSpecialVictoryPoint) {
		fields = append(fields, card.FieldSpecialVictoryPoint)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CardMutation) ClearField(name string) error {
	switch name {
	case card.FieldPrintedID:
		m.ClearPrintedID()
		return nil
	case card.FieldPlayAgricolaCardID:
		m.ClearPlayAgricolaCardID()
		return nil
	case card.FieldDeckID:
		m.ClearDeckID()
		return nil
	case card.FieldCardSpecialColorID:
		m.ClearCardSpecialColorID()
		return nil
	case card.FieldNameJa:
		m.ClearNameJa()
		return nil
	case card.FieldNameEn:
		m.ClearNameEn()
		return nil
	case card.FieldMinPlayersNumber:
		m.ClearMinPlayersNumber()
		return nil
	case card.FieldPrerequisite:
		m.ClearPrerequisite()
		return nil
	case card.FieldCost:
		m.ClearCost()
		return nil
	case card.FieldDescription:
		m.ClearDescription()
		return nil
	case card.FieldVictoryPoint:
		m.ClearVictoryPoint()
		return nil
	case card.FieldSpecialVictoryPoint:
		m.ClearSpecialVictoryPoint()
		return nil
	}
	return fmt.Errorf("unknown Card nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CardMutation) ResetField(name string) error {
	switch name {
	case card.FieldLiteralID:
		m.ResetLiteralID()
		return nil
	case card.FieldRevisionID:
		m.ResetRevisionID()
		return nil
	case card.FieldPrintedID:
		m.ResetPrintedID()
		return nil
	case card.FieldPlayAgricolaCardID:
		m.ResetPlayAgricolaCardID()
		return nil
	case card.FieldDeckID:
		m.ResetDeckID()
		return nil
	case card.FieldCardTypeID:
		m.ResetCardTypeID()
		return nil
	case card.FieldCardSpecialColorID:
		m.ResetCardSpecialColorID()
		return nil
	case card.FieldNameJa:
		m.ResetNameJa()
		return nil
	case card.FieldNameEn:
		m.ResetNameEn()
		return nil
	case card.FieldMinPlayersNumber:
		m.ResetMinPlayersNumber()
		return nil
	case card.FieldPrerequisite:
		m.ResetPrerequisite()
		return nil
	case card.FieldCost:
		m.ResetCost()
		return nil
	case card.FieldDescription:
		m.ResetDescription()
		return nil
	case card.FieldIsOfficialJa:
		m.ResetIsOfficialJa()
		return nil
	case card.FieldVictoryPoint:
		m.ResetVictoryPoint()
		return nil
	case card.FieldSpecialVictoryPoint:
		m.ResetSpecialVictoryPoint()
		return nil
	case card.FieldHasArrrow:
		m.ResetHasArrrow()
		return nil
	case card.FieldHasBonusPointIcon:
		m.ResetHasBonusPointIcon()
		return nil
	case card.FieldHasNegativeBonusPointIcon:
		m.ResetHasNegativeBonusPointIcon()
		return nil
	case card.FieldHasPanIcon:
		m.ResetHasPanIcon()
		return nil
	case card.FieldHasBreadIcon:
		m.ResetHasBreadIcon()
		return nil
	case card.FieldHasFarmPlannerIcon:
		m.ResetHasFarmPlannerIcon()
		return nil
	case card.FieldHasActionsBoosterIcon:
		m.ResetHasActionsBoosterIcon()
		return nil
	case card.FieldHasPointsProviderIcon:
		m.ResetHasPointsProviderIcon()
		return nil
	case card.FieldHasGoodsProviderIcon:
		m.ResetHasGoodsProviderIcon()
		return nil
	case card.FieldHasFoodProviderIcon:
		m.ResetHasFoodProviderIcon()
		return nil
	case card.FieldHasCropProviderIcon:
		m.ResetHasCropProviderIcon()
		return nil
	case card.FieldHasBuildingResourceProviderIcon:
		m.ResetHasBuildingResourceProviderIcon()
		return nil
	case card.FieldHasLivestockProviderIcon:
		m.ResetHasLivestockProviderIcon()
		return nil
	case card.FieldHasCutPeatIcon:
		m.ResetHasCutPeatIcon()
		return nil
	case card.FieldHasFellTreesIcon:
		m.ResetHasFellTreesIcon()
		return nil
	case card.FieldHasSlashAndBurnIcon:
		m.ResetHasSlashAndBurnIcon()
		return nil
	case card.FieldHasHiringFareIcon:
		m.ResetHasHiringFareIcon()
		return nil
	}
	return fmt.Errorf("unknown Card field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CardMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.revision != nil {
		edges = append(edges, card.EdgeRevision)
	}
	if m.products != nil {
		edges = append(edges, card.EdgeProducts)
	}
	if m.deck != nil {
		edges = append(edges, card.EdgeDeck)
	}
	if m.card_type != nil {
		edges = append(edges, card.EdgeCardType)
	}
	if m.card_special_color != nil {
		edges = append(edges, card.EdgeCardSpecialColor)
	}
	if m.children != nil {
		edges = append(edges, card.EdgeChildren)
	}
	if m.ancestors != nil {
		edges = append(edges, card.EdgeAncestors)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case card.EdgeRevision:
		if id := m.revision; id != nil {
			return []ent.Value{*id}
		}
	case card.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case card.EdgeDeck:
		if id := m.deck; id != nil {
			return []ent.Value{*id}
		}
	case card.EdgeCardType:
		if id := m.card_type; id != nil {
			return []ent.Value{*id}
		}
	case card.EdgeCardSpecialColor:
		if id := m.card_special_color; id != nil {
			return []ent.Value{*id}
		}
	case card.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case card.EdgeAncestors:
		ids := make([]ent.Value, 0, len(m.ancestors))
		for id := range m.ancestors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedproducts != nil {
		edges = append(edges, card.EdgeProducts)
	}
	if m.removedchildren != nil {
		edges = append(edges, card.EdgeChildren)
	}
	if m.removedancestors != nil {
		edges = append(edges, card.EdgeAncestors)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CardMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case card.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	case card.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case card.EdgeAncestors:
		ids := make([]ent.Value, 0, len(m.removedancestors))
		for id := range m.removedancestors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedrevision {
		edges = append(edges, card.EdgeRevision)
	}
	if m.clearedproducts {
		edges = append(edges, card.EdgeProducts)
	}
	if m.cleareddeck {
		edges = append(edges, card.EdgeDeck)
	}
	if m.clearedcard_type {
		edges = append(edges, card.EdgeCardType)
	}
	if m.clearedcard_special_color {
		edges = append(edges, card.EdgeCardSpecialColor)
	}
	if m.clearedchildren {
		edges = append(edges, card.EdgeChildren)
	}
	if m.clearedancestors {
		edges = append(edges, card.EdgeAncestors)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CardMutation) EdgeCleared(name string) bool {
	switch name {
	case card.EdgeRevision:
		return m.clearedrevision
	case card.EdgeProducts:
		return m.clearedproducts
	case card.EdgeDeck:
		return m.cleareddeck
	case card.EdgeCardType:
		return m.clearedcard_type
	case card.EdgeCardSpecialColor:
		return m.clearedcard_special_color
	case card.EdgeChildren:
		return m.clearedchildren
	case card.EdgeAncestors:
		return m.clearedancestors
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CardMutation) ClearEdge(name string) error {
	switch name {
	case card.EdgeRevision:
		m.ClearRevision()
		return nil
	case card.EdgeDeck:
		m.ClearDeck()
		return nil
	case card.EdgeCardType:
		m.ClearCardType()
		return nil
	case card.EdgeCardSpecialColor:
		m.ClearCardSpecialColor()
		return nil
	}
	return fmt.Errorf("unknown Card unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CardMutation) ResetEdge(name string) error {
	switch name {
	case card.EdgeRevision:
		m.ResetRevision()
		return nil
	case card.EdgeProducts:
		m.ResetProducts()
		return nil
	case card.EdgeDeck:
		m.ResetDeck()
		return nil
	case card.EdgeCardType:
		m.ResetCardType()
		return nil
	case card.EdgeCardSpecialColor:
		m.ResetCardSpecialColor()
		return nil
	case card.EdgeChildren:
		m.ResetChildren()
		return nil
	case card.EdgeAncestors:
		m.ResetAncestors()
		return nil
	}
	return fmt.Errorf("unknown Card edge %s", name)
}

// CardSpecialColorMutation represents an operation that mutates the CardSpecialColor nodes in the graph.
type CardSpecialColorMutation struct {
	config
	op            Op
	typ           string
	id            *int
	key           *string
	name_ja       *string
	name_en       *string
	clearedFields map[string]struct{}
	cards         map[int]struct{}
	removedcards  map[int]struct{}
	clearedcards  bool
	done          bool
	oldValue      func(context.Context) (*CardSpecialColor, error)
	predicates    []predicate.CardSpecialColor
}

var _ ent.Mutation = (*CardSpecialColorMutation)(nil)

// cardspecialcolorOption allows management of the mutation configuration using functional options.
type cardspecialcolorOption func(*CardSpecialColorMutation)

// newCardSpecialColorMutation creates new mutation for the CardSpecialColor entity.
func newCardSpecialColorMutation(c config, op Op, opts ...cardspecialcolorOption) *CardSpecialColorMutation {
	m := &CardSpecialColorMutation{
		config:        c,
		op:            op,
		typ:           TypeCardSpecialColor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCardSpecialColorID sets the ID field of the mutation.
func withCardSpecialColorID(id int) cardspecialcolorOption {
	return func(m *CardSpecialColorMutation) {
		var (
			err   error
			once  sync.Once
			value *CardSpecialColor
		)
		m.oldValue = func(ctx context.Context) (*CardSpecialColor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CardSpecialColor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCardSpecialColor sets the old CardSpecialColor of the mutation.
func withCardSpecialColor(node *CardSpecialColor) cardspecialcolorOption {
	return func(m *CardSpecialColorMutation) {
		m.oldValue = func(context.Context) (*CardSpecialColor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CardSpecialColorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CardSpecialColorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CardSpecialColorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CardSpecialColorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CardSpecialColor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *CardSpecialColorMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *CardSpecialColorMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the CardSpecialColor entity.
// If the CardSpecialColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardSpecialColorMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *CardSpecialColorMutation) ResetKey() {
	m.key = nil
}

// SetNameJa sets the "name_ja" field.
func (m *CardSpecialColorMutation) SetNameJa(s string) {
	m.name_ja = &s
}

// NameJa returns the value of the "name_ja" field in the mutation.
func (m *CardSpecialColorMutation) NameJa() (r string, exists bool) {
	v := m.name_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJa returns the old "name_ja" field's value of the CardSpecialColor entity.
// If the CardSpecialColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardSpecialColorMutation) OldNameJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJa: %w", err)
	}
	return oldValue.NameJa, nil
}

// ClearNameJa clears the value of the "name_ja" field.
func (m *CardSpecialColorMutation) ClearNameJa() {
	m.name_ja = nil
	m.clearedFields[cardspecialcolor.FieldNameJa] = struct{}{}
}

// NameJaCleared returns if the "name_ja" field was cleared in this mutation.
func (m *CardSpecialColorMutation) NameJaCleared() bool {
	_, ok := m.clearedFields[cardspecialcolor.FieldNameJa]
	return ok
}

// ResetNameJa resets all changes to the "name_ja" field.
func (m *CardSpecialColorMutation) ResetNameJa() {
	m.name_ja = nil
	delete(m.clearedFields, cardspecialcolor.FieldNameJa)
}

// SetNameEn sets the "name_en" field.
func (m *CardSpecialColorMutation) SetNameEn(s string) {
	m.name_en = &s
}

// NameEn returns the value of the "name_en" field in the mutation.
func (m *CardSpecialColorMutation) NameEn() (r string, exists bool) {
	v := m.name_en
	if v == nil {
		return
	}
	return *v, true
}

// OldNameEn returns the old "name_en" field's value of the CardSpecialColor entity.
// If the CardSpecialColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardSpecialColorMutation) OldNameEn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameEn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameEn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameEn: %w", err)
	}
	return oldValue.NameEn, nil
}

// ClearNameEn clears the value of the "name_en" field.
func (m *CardSpecialColorMutation) ClearNameEn() {
	m.name_en = nil
	m.clearedFields[cardspecialcolor.FieldNameEn] = struct{}{}
}

// NameEnCleared returns if the "name_en" field was cleared in this mutation.
func (m *CardSpecialColorMutation) NameEnCleared() bool {
	_, ok := m.clearedFields[cardspecialcolor.FieldNameEn]
	return ok
}

// ResetNameEn resets all changes to the "name_en" field.
func (m *CardSpecialColorMutation) ResetNameEn() {
	m.name_en = nil
	delete(m.clearedFields, cardspecialcolor.FieldNameEn)
}

// AddCardIDs adds the "cards" edge to the Card entity by ids.
func (m *CardSpecialColorMutation) AddCardIDs(ids ...int) {
	if m.cards == nil {
		m.cards = make(map[int]struct{})
	}
	for i := range ids {
		m.cards[ids[i]] = struct{}{}
	}
}

// ClearCards clears the "cards" edge to the Card entity.
func (m *CardSpecialColorMutation) ClearCards() {
	m.clearedcards = true
}

// CardsCleared reports if the "cards" edge to the Card entity was cleared.
func (m *CardSpecialColorMutation) CardsCleared() bool {
	return m.clearedcards
}

// RemoveCardIDs removes the "cards" edge to the Card entity by IDs.
func (m *CardSpecialColorMutation) RemoveCardIDs(ids ...int) {
	if m.removedcards == nil {
		m.removedcards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cards, ids[i])
		m.removedcards[ids[i]] = struct{}{}
	}
}

// RemovedCards returns the removed IDs of the "cards" edge to the Card entity.
func (m *CardSpecialColorMutation) RemovedCardsIDs() (ids []int) {
	for id := range m.removedcards {
		ids = append(ids, id)
	}
	return
}

// CardsIDs returns the "cards" edge IDs in the mutation.
func (m *CardSpecialColorMutation) CardsIDs() (ids []int) {
	for id := range m.cards {
		ids = append(ids, id)
	}
	return
}

// ResetCards resets all changes to the "cards" edge.
func (m *CardSpecialColorMutation) ResetCards() {
	m.cards = nil
	m.clearedcards = false
	m.removedcards = nil
}

// Where appends a list predicates to the CardSpecialColorMutation builder.
func (m *CardSpecialColorMutation) Where(ps ...predicate.CardSpecialColor) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CardSpecialColorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CardSpecialColor).
func (m *CardSpecialColorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CardSpecialColorMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.key != nil {
		fields = append(fields, cardspecialcolor.FieldKey)
	}
	if m.name_ja != nil {
		fields = append(fields, cardspecialcolor.FieldNameJa)
	}
	if m.name_en != nil {
		fields = append(fields, cardspecialcolor.FieldNameEn)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CardSpecialColorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cardspecialcolor.FieldKey:
		return m.Key()
	case cardspecialcolor.FieldNameJa:
		return m.NameJa()
	case cardspecialcolor.FieldNameEn:
		return m.NameEn()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CardSpecialColorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cardspecialcolor.FieldKey:
		return m.OldKey(ctx)
	case cardspecialcolor.FieldNameJa:
		return m.OldNameJa(ctx)
	case cardspecialcolor.FieldNameEn:
		return m.OldNameEn(ctx)
	}
	return nil, fmt.Errorf("unknown CardSpecialColor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardSpecialColorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cardspecialcolor.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case cardspecialcolor.FieldNameJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJa(v)
		return nil
	case cardspecialcolor.FieldNameEn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameEn(v)
		return nil
	}
	return fmt.Errorf("unknown CardSpecialColor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CardSpecialColorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CardSpecialColorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardSpecialColorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CardSpecialColor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CardSpecialColorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cardspecialcolor.FieldNameJa) {
		fields = append(fields, cardspecialcolor.FieldNameJa)
	}
	if m.FieldCleared(cardspecialcolor.FieldNameEn) {
		fields = append(fields, cardspecialcolor.FieldNameEn)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CardSpecialColorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CardSpecialColorMutation) ClearField(name string) error {
	switch name {
	case cardspecialcolor.FieldNameJa:
		m.ClearNameJa()
		return nil
	case cardspecialcolor.FieldNameEn:
		m.ClearNameEn()
		return nil
	}
	return fmt.Errorf("unknown CardSpecialColor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CardSpecialColorMutation) ResetField(name string) error {
	switch name {
	case cardspecialcolor.FieldKey:
		m.ResetKey()
		return nil
	case cardspecialcolor.FieldNameJa:
		m.ResetNameJa()
		return nil
	case cardspecialcolor.FieldNameEn:
		m.ResetNameEn()
		return nil
	}
	return fmt.Errorf("unknown CardSpecialColor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CardSpecialColorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cards != nil {
		edges = append(edges, cardspecialcolor.EdgeCards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CardSpecialColorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cardspecialcolor.EdgeCards:
		ids := make([]ent.Value, 0, len(m.cards))
		for id := range m.cards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CardSpecialColorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcards != nil {
		edges = append(edges, cardspecialcolor.EdgeCards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CardSpecialColorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cardspecialcolor.EdgeCards:
		ids := make([]ent.Value, 0, len(m.removedcards))
		for id := range m.removedcards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CardSpecialColorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcards {
		edges = append(edges, cardspecialcolor.EdgeCards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CardSpecialColorMutation) EdgeCleared(name string) bool {
	switch name {
	case cardspecialcolor.EdgeCards:
		return m.clearedcards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CardSpecialColorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CardSpecialColor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CardSpecialColorMutation) ResetEdge(name string) error {
	switch name {
	case cardspecialcolor.EdgeCards:
		m.ResetCards()
		return nil
	}
	return fmt.Errorf("unknown CardSpecialColor edge %s", name)
}

// CardTypeMutation represents an operation that mutates the CardType nodes in the graph.
type CardTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	key           *string
	name_ja       *string
	name_en       *string
	clearedFields map[string]struct{}
	cards         map[int]struct{}
	removedcards  map[int]struct{}
	clearedcards  bool
	done          bool
	oldValue      func(context.Context) (*CardType, error)
	predicates    []predicate.CardType
}

var _ ent.Mutation = (*CardTypeMutation)(nil)

// cardtypeOption allows management of the mutation configuration using functional options.
type cardtypeOption func(*CardTypeMutation)

// newCardTypeMutation creates new mutation for the CardType entity.
func newCardTypeMutation(c config, op Op, opts ...cardtypeOption) *CardTypeMutation {
	m := &CardTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCardType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCardTypeID sets the ID field of the mutation.
func withCardTypeID(id int) cardtypeOption {
	return func(m *CardTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CardType
		)
		m.oldValue = func(ctx context.Context) (*CardType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CardType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCardType sets the old CardType of the mutation.
func withCardType(node *CardType) cardtypeOption {
	return func(m *CardTypeMutation) {
		m.oldValue = func(context.Context) (*CardType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CardTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CardTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CardTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CardTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CardType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *CardTypeMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *CardTypeMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the CardType entity.
// If the CardType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardTypeMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *CardTypeMutation) ResetKey() {
	m.key = nil
}

// SetNameJa sets the "name_ja" field.
func (m *CardTypeMutation) SetNameJa(s string) {
	m.name_ja = &s
}

// NameJa returns the value of the "name_ja" field in the mutation.
func (m *CardTypeMutation) NameJa() (r string, exists bool) {
	v := m.name_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJa returns the old "name_ja" field's value of the CardType entity.
// If the CardType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardTypeMutation) OldNameJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJa: %w", err)
	}
	return oldValue.NameJa, nil
}

// ClearNameJa clears the value of the "name_ja" field.
func (m *CardTypeMutation) ClearNameJa() {
	m.name_ja = nil
	m.clearedFields[cardtype.FieldNameJa] = struct{}{}
}

// NameJaCleared returns if the "name_ja" field was cleared in this mutation.
func (m *CardTypeMutation) NameJaCleared() bool {
	_, ok := m.clearedFields[cardtype.FieldNameJa]
	return ok
}

// ResetNameJa resets all changes to the "name_ja" field.
func (m *CardTypeMutation) ResetNameJa() {
	m.name_ja = nil
	delete(m.clearedFields, cardtype.FieldNameJa)
}

// SetNameEn sets the "name_en" field.
func (m *CardTypeMutation) SetNameEn(s string) {
	m.name_en = &s
}

// NameEn returns the value of the "name_en" field in the mutation.
func (m *CardTypeMutation) NameEn() (r string, exists bool) {
	v := m.name_en
	if v == nil {
		return
	}
	return *v, true
}

// OldNameEn returns the old "name_en" field's value of the CardType entity.
// If the CardType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardTypeMutation) OldNameEn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameEn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameEn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameEn: %w", err)
	}
	return oldValue.NameEn, nil
}

// ClearNameEn clears the value of the "name_en" field.
func (m *CardTypeMutation) ClearNameEn() {
	m.name_en = nil
	m.clearedFields[cardtype.FieldNameEn] = struct{}{}
}

// NameEnCleared returns if the "name_en" field was cleared in this mutation.
func (m *CardTypeMutation) NameEnCleared() bool {
	_, ok := m.clearedFields[cardtype.FieldNameEn]
	return ok
}

// ResetNameEn resets all changes to the "name_en" field.
func (m *CardTypeMutation) ResetNameEn() {
	m.name_en = nil
	delete(m.clearedFields, cardtype.FieldNameEn)
}

// AddCardIDs adds the "cards" edge to the Card entity by ids.
func (m *CardTypeMutation) AddCardIDs(ids ...int) {
	if m.cards == nil {
		m.cards = make(map[int]struct{})
	}
	for i := range ids {
		m.cards[ids[i]] = struct{}{}
	}
}

// ClearCards clears the "cards" edge to the Card entity.
func (m *CardTypeMutation) ClearCards() {
	m.clearedcards = true
}

// CardsCleared reports if the "cards" edge to the Card entity was cleared.
func (m *CardTypeMutation) CardsCleared() bool {
	return m.clearedcards
}

// RemoveCardIDs removes the "cards" edge to the Card entity by IDs.
func (m *CardTypeMutation) RemoveCardIDs(ids ...int) {
	if m.removedcards == nil {
		m.removedcards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cards, ids[i])
		m.removedcards[ids[i]] = struct{}{}
	}
}

// RemovedCards returns the removed IDs of the "cards" edge to the Card entity.
func (m *CardTypeMutation) RemovedCardsIDs() (ids []int) {
	for id := range m.removedcards {
		ids = append(ids, id)
	}
	return
}

// CardsIDs returns the "cards" edge IDs in the mutation.
func (m *CardTypeMutation) CardsIDs() (ids []int) {
	for id := range m.cards {
		ids = append(ids, id)
	}
	return
}

// ResetCards resets all changes to the "cards" edge.
func (m *CardTypeMutation) ResetCards() {
	m.cards = nil
	m.clearedcards = false
	m.removedcards = nil
}

// Where appends a list predicates to the CardTypeMutation builder.
func (m *CardTypeMutation) Where(ps ...predicate.CardType) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CardTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CardType).
func (m *CardTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CardTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.key != nil {
		fields = append(fields, cardtype.FieldKey)
	}
	if m.name_ja != nil {
		fields = append(fields, cardtype.FieldNameJa)
	}
	if m.name_en != nil {
		fields = append(fields, cardtype.FieldNameEn)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CardTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cardtype.FieldKey:
		return m.Key()
	case cardtype.FieldNameJa:
		return m.NameJa()
	case cardtype.FieldNameEn:
		return m.NameEn()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CardTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cardtype.FieldKey:
		return m.OldKey(ctx)
	case cardtype.FieldNameJa:
		return m.OldNameJa(ctx)
	case cardtype.FieldNameEn:
		return m.OldNameEn(ctx)
	}
	return nil, fmt.Errorf("unknown CardType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cardtype.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case cardtype.FieldNameJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJa(v)
		return nil
	case cardtype.FieldNameEn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameEn(v)
		return nil
	}
	return fmt.Errorf("unknown CardType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CardTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CardTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CardType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CardTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cardtype.FieldNameJa) {
		fields = append(fields, cardtype.FieldNameJa)
	}
	if m.FieldCleared(cardtype.FieldNameEn) {
		fields = append(fields, cardtype.FieldNameEn)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CardTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CardTypeMutation) ClearField(name string) error {
	switch name {
	case cardtype.FieldNameJa:
		m.ClearNameJa()
		return nil
	case cardtype.FieldNameEn:
		m.ClearNameEn()
		return nil
	}
	return fmt.Errorf("unknown CardType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CardTypeMutation) ResetField(name string) error {
	switch name {
	case cardtype.FieldKey:
		m.ResetKey()
		return nil
	case cardtype.FieldNameJa:
		m.ResetNameJa()
		return nil
	case cardtype.FieldNameEn:
		m.ResetNameEn()
		return nil
	}
	return fmt.Errorf("unknown CardType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CardTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cards != nil {
		edges = append(edges, cardtype.EdgeCards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CardTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cardtype.EdgeCards:
		ids := make([]ent.Value, 0, len(m.cards))
		for id := range m.cards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CardTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcards != nil {
		edges = append(edges, cardtype.EdgeCards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CardTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cardtype.EdgeCards:
		ids := make([]ent.Value, 0, len(m.removedcards))
		for id := range m.removedcards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CardTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcards {
		edges = append(edges, cardtype.EdgeCards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CardTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case cardtype.EdgeCards:
		return m.clearedcards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CardTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CardType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CardTypeMutation) ResetEdge(name string) error {
	switch name {
	case cardtype.EdgeCards:
		m.ResetCards()
		return nil
	}
	return fmt.Errorf("unknown CardType edge %s", name)
}

// DeckMutation represents an operation that mutates the Deck nodes in the graph.
type DeckMutation struct {
	config
	op              Op
	typ             string
	id              *int
	key             *string
	name_ja         *string
	name_en         *string
	clearedFields   map[string]struct{}
	cards           map[int]struct{}
	removedcards    map[int]struct{}
	clearedcards    bool
	revision        *int
	clearedrevision bool
	done            bool
	oldValue        func(context.Context) (*Deck, error)
	predicates      []predicate.Deck
}

var _ ent.Mutation = (*DeckMutation)(nil)

// deckOption allows management of the mutation configuration using functional options.
type deckOption func(*DeckMutation)

// newDeckMutation creates new mutation for the Deck entity.
func newDeckMutation(c config, op Op, opts ...deckOption) *DeckMutation {
	m := &DeckMutation{
		config:        c,
		op:            op,
		typ:           TypeDeck,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeckID sets the ID field of the mutation.
func withDeckID(id int) deckOption {
	return func(m *DeckMutation) {
		var (
			err   error
			once  sync.Once
			value *Deck
		)
		m.oldValue = func(ctx context.Context) (*Deck, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Deck.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeck sets the old Deck of the mutation.
func withDeck(node *Deck) deckOption {
	return func(m *DeckMutation) {
		m.oldValue = func(context.Context) (*Deck, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeckMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeckMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeckMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeckMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Deck.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *DeckMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *DeckMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *DeckMutation) ResetKey() {
	m.key = nil
}

// SetRevisionID sets the "revision_id" field.
func (m *DeckMutation) SetRevisionID(i int) {
	m.revision = &i
}

// RevisionID returns the value of the "revision_id" field in the mutation.
func (m *DeckMutation) RevisionID() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevisionID returns the old "revision_id" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldRevisionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevisionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevisionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevisionID: %w", err)
	}
	return oldValue.RevisionID, nil
}

// ResetRevisionID resets all changes to the "revision_id" field.
func (m *DeckMutation) ResetRevisionID() {
	m.revision = nil
}

// SetNameJa sets the "name_ja" field.
func (m *DeckMutation) SetNameJa(s string) {
	m.name_ja = &s
}

// NameJa returns the value of the "name_ja" field in the mutation.
func (m *DeckMutation) NameJa() (r string, exists bool) {
	v := m.name_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJa returns the old "name_ja" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldNameJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJa: %w", err)
	}
	return oldValue.NameJa, nil
}

// ClearNameJa clears the value of the "name_ja" field.
func (m *DeckMutation) ClearNameJa() {
	m.name_ja = nil
	m.clearedFields[deck.FieldNameJa] = struct{}{}
}

// NameJaCleared returns if the "name_ja" field was cleared in this mutation.
func (m *DeckMutation) NameJaCleared() bool {
	_, ok := m.clearedFields[deck.FieldNameJa]
	return ok
}

// ResetNameJa resets all changes to the "name_ja" field.
func (m *DeckMutation) ResetNameJa() {
	m.name_ja = nil
	delete(m.clearedFields, deck.FieldNameJa)
}

// SetNameEn sets the "name_en" field.
func (m *DeckMutation) SetNameEn(s string) {
	m.name_en = &s
}

// NameEn returns the value of the "name_en" field in the mutation.
func (m *DeckMutation) NameEn() (r string, exists bool) {
	v := m.name_en
	if v == nil {
		return
	}
	return *v, true
}

// OldNameEn returns the old "name_en" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldNameEn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameEn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameEn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameEn: %w", err)
	}
	return oldValue.NameEn, nil
}

// ClearNameEn clears the value of the "name_en" field.
func (m *DeckMutation) ClearNameEn() {
	m.name_en = nil
	m.clearedFields[deck.FieldNameEn] = struct{}{}
}

// NameEnCleared returns if the "name_en" field was cleared in this mutation.
func (m *DeckMutation) NameEnCleared() bool {
	_, ok := m.clearedFields[deck.FieldNameEn]
	return ok
}

// ResetNameEn resets all changes to the "name_en" field.
func (m *DeckMutation) ResetNameEn() {
	m.name_en = nil
	delete(m.clearedFields, deck.FieldNameEn)
}

// AddCardIDs adds the "cards" edge to the Card entity by ids.
func (m *DeckMutation) AddCardIDs(ids ...int) {
	if m.cards == nil {
		m.cards = make(map[int]struct{})
	}
	for i := range ids {
		m.cards[ids[i]] = struct{}{}
	}
}

// ClearCards clears the "cards" edge to the Card entity.
func (m *DeckMutation) ClearCards() {
	m.clearedcards = true
}

// CardsCleared reports if the "cards" edge to the Card entity was cleared.
func (m *DeckMutation) CardsCleared() bool {
	return m.clearedcards
}

// RemoveCardIDs removes the "cards" edge to the Card entity by IDs.
func (m *DeckMutation) RemoveCardIDs(ids ...int) {
	if m.removedcards == nil {
		m.removedcards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cards, ids[i])
		m.removedcards[ids[i]] = struct{}{}
	}
}

// RemovedCards returns the removed IDs of the "cards" edge to the Card entity.
func (m *DeckMutation) RemovedCardsIDs() (ids []int) {
	for id := range m.removedcards {
		ids = append(ids, id)
	}
	return
}

// CardsIDs returns the "cards" edge IDs in the mutation.
func (m *DeckMutation) CardsIDs() (ids []int) {
	for id := range m.cards {
		ids = append(ids, id)
	}
	return
}

// ResetCards resets all changes to the "cards" edge.
func (m *DeckMutation) ResetCards() {
	m.cards = nil
	m.clearedcards = false
	m.removedcards = nil
}

// ClearRevision clears the "revision" edge to the Revision entity.
func (m *DeckMutation) ClearRevision() {
	m.clearedrevision = true
}

// RevisionCleared reports if the "revision" edge to the Revision entity was cleared.
func (m *DeckMutation) RevisionCleared() bool {
	return m.clearedrevision
}

// RevisionIDs returns the "revision" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RevisionID instead. It exists only for internal usage by the builders.
func (m *DeckMutation) RevisionIDs() (ids []int) {
	if id := m.revision; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRevision resets all changes to the "revision" edge.
func (m *DeckMutation) ResetRevision() {
	m.revision = nil
	m.clearedrevision = false
}

// Where appends a list predicates to the DeckMutation builder.
func (m *DeckMutation) Where(ps ...predicate.Deck) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeckMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Deck).
func (m *DeckMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeckMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.key != nil {
		fields = append(fields, deck.FieldKey)
	}
	if m.revision != nil {
		fields = append(fields, deck.FieldRevisionID)
	}
	if m.name_ja != nil {
		fields = append(fields, deck.FieldNameJa)
	}
	if m.name_en != nil {
		fields = append(fields, deck.FieldNameEn)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeckMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deck.FieldKey:
		return m.Key()
	case deck.FieldRevisionID:
		return m.RevisionID()
	case deck.FieldNameJa:
		return m.NameJa()
	case deck.FieldNameEn:
		return m.NameEn()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeckMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deck.FieldKey:
		return m.OldKey(ctx)
	case deck.FieldRevisionID:
		return m.OldRevisionID(ctx)
	case deck.FieldNameJa:
		return m.OldNameJa(ctx)
	case deck.FieldNameEn:
		return m.OldNameEn(ctx)
	}
	return nil, fmt.Errorf("unknown Deck field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeckMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deck.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case deck.FieldRevisionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevisionID(v)
		return nil
	case deck.FieldNameJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJa(v)
		return nil
	case deck.FieldNameEn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameEn(v)
		return nil
	}
	return fmt.Errorf("unknown Deck field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeckMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeckMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeckMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Deck numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeckMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deck.FieldNameJa) {
		fields = append(fields, deck.FieldNameJa)
	}
	if m.FieldCleared(deck.FieldNameEn) {
		fields = append(fields, deck.FieldNameEn)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeckMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeckMutation) ClearField(name string) error {
	switch name {
	case deck.FieldNameJa:
		m.ClearNameJa()
		return nil
	case deck.FieldNameEn:
		m.ClearNameEn()
		return nil
	}
	return fmt.Errorf("unknown Deck nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeckMutation) ResetField(name string) error {
	switch name {
	case deck.FieldKey:
		m.ResetKey()
		return nil
	case deck.FieldRevisionID:
		m.ResetRevisionID()
		return nil
	case deck.FieldNameJa:
		m.ResetNameJa()
		return nil
	case deck.FieldNameEn:
		m.ResetNameEn()
		return nil
	}
	return fmt.Errorf("unknown Deck field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeckMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cards != nil {
		edges = append(edges, deck.EdgeCards)
	}
	if m.revision != nil {
		edges = append(edges, deck.EdgeRevision)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeckMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deck.EdgeCards:
		ids := make([]ent.Value, 0, len(m.cards))
		for id := range m.cards {
			ids = append(ids, id)
		}
		return ids
	case deck.EdgeRevision:
		if id := m.revision; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeckMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcards != nil {
		edges = append(edges, deck.EdgeCards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeckMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deck.EdgeCards:
		ids := make([]ent.Value, 0, len(m.removedcards))
		for id := range m.removedcards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeckMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcards {
		edges = append(edges, deck.EdgeCards)
	}
	if m.clearedrevision {
		edges = append(edges, deck.EdgeRevision)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeckMutation) EdgeCleared(name string) bool {
	switch name {
	case deck.EdgeCards:
		return m.clearedcards
	case deck.EdgeRevision:
		return m.clearedrevision
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeckMutation) ClearEdge(name string) error {
	switch name {
	case deck.EdgeRevision:
		m.ClearRevision()
		return nil
	}
	return fmt.Errorf("unknown Deck unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeckMutation) ResetEdge(name string) error {
	switch name {
	case deck.EdgeCards:
		m.ResetCards()
		return nil
	case deck.EdgeRevision:
		m.ResetRevision()
		return nil
	}
	return fmt.Errorf("unknown Deck edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op              Op
	typ             string
	id              *int
	key             *string
	is_official_ja  *bool
	name_ja         *string
	name_en         *string
	clearedFields   map[string]struct{}
	cards           map[int]struct{}
	removedcards    map[int]struct{}
	clearedcards    bool
	revision        *int
	clearedrevision bool
	done            bool
	oldValue        func(context.Context) (*Product, error)
	predicates      []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *ProductMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *ProductMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *ProductMutation) ResetKey() {
	m.key = nil
}

// SetRevisionID sets the "revision_id" field.
func (m *ProductMutation) SetRevisionID(i int) {
	m.revision = &i
}

// RevisionID returns the value of the "revision_id" field in the mutation.
func (m *ProductMutation) RevisionID() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevisionID returns the old "revision_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldRevisionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevisionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevisionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevisionID: %w", err)
	}
	return oldValue.RevisionID, nil
}

// ResetRevisionID resets all changes to the "revision_id" field.
func (m *ProductMutation) ResetRevisionID() {
	m.revision = nil
}

// SetIsOfficialJa sets the "is_official_ja" field.
func (m *ProductMutation) SetIsOfficialJa(b bool) {
	m.is_official_ja = &b
}

// IsOfficialJa returns the value of the "is_official_ja" field in the mutation.
func (m *ProductMutation) IsOfficialJa() (r bool, exists bool) {
	v := m.is_official_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOfficialJa returns the old "is_official_ja" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldIsOfficialJa(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOfficialJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOfficialJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOfficialJa: %w", err)
	}
	return oldValue.IsOfficialJa, nil
}

// ResetIsOfficialJa resets all changes to the "is_official_ja" field.
func (m *ProductMutation) ResetIsOfficialJa() {
	m.is_official_ja = nil
}

// SetNameJa sets the "name_ja" field.
func (m *ProductMutation) SetNameJa(s string) {
	m.name_ja = &s
}

// NameJa returns the value of the "name_ja" field in the mutation.
func (m *ProductMutation) NameJa() (r string, exists bool) {
	v := m.name_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJa returns the old "name_ja" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldNameJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJa: %w", err)
	}
	return oldValue.NameJa, nil
}

// ClearNameJa clears the value of the "name_ja" field.
func (m *ProductMutation) ClearNameJa() {
	m.name_ja = nil
	m.clearedFields[product.FieldNameJa] = struct{}{}
}

// NameJaCleared returns if the "name_ja" field was cleared in this mutation.
func (m *ProductMutation) NameJaCleared() bool {
	_, ok := m.clearedFields[product.FieldNameJa]
	return ok
}

// ResetNameJa resets all changes to the "name_ja" field.
func (m *ProductMutation) ResetNameJa() {
	m.name_ja = nil
	delete(m.clearedFields, product.FieldNameJa)
}

// SetNameEn sets the "name_en" field.
func (m *ProductMutation) SetNameEn(s string) {
	m.name_en = &s
}

// NameEn returns the value of the "name_en" field in the mutation.
func (m *ProductMutation) NameEn() (r string, exists bool) {
	v := m.name_en
	if v == nil {
		return
	}
	return *v, true
}

// OldNameEn returns the old "name_en" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldNameEn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameEn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameEn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameEn: %w", err)
	}
	return oldValue.NameEn, nil
}

// ClearNameEn clears the value of the "name_en" field.
func (m *ProductMutation) ClearNameEn() {
	m.name_en = nil
	m.clearedFields[product.FieldNameEn] = struct{}{}
}

// NameEnCleared returns if the "name_en" field was cleared in this mutation.
func (m *ProductMutation) NameEnCleared() bool {
	_, ok := m.clearedFields[product.FieldNameEn]
	return ok
}

// ResetNameEn resets all changes to the "name_en" field.
func (m *ProductMutation) ResetNameEn() {
	m.name_en = nil
	delete(m.clearedFields, product.FieldNameEn)
}

// AddCardIDs adds the "cards" edge to the Card entity by ids.
func (m *ProductMutation) AddCardIDs(ids ...int) {
	if m.cards == nil {
		m.cards = make(map[int]struct{})
	}
	for i := range ids {
		m.cards[ids[i]] = struct{}{}
	}
}

// ClearCards clears the "cards" edge to the Card entity.
func (m *ProductMutation) ClearCards() {
	m.clearedcards = true
}

// CardsCleared reports if the "cards" edge to the Card entity was cleared.
func (m *ProductMutation) CardsCleared() bool {
	return m.clearedcards
}

// RemoveCardIDs removes the "cards" edge to the Card entity by IDs.
func (m *ProductMutation) RemoveCardIDs(ids ...int) {
	if m.removedcards == nil {
		m.removedcards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cards, ids[i])
		m.removedcards[ids[i]] = struct{}{}
	}
}

// RemovedCards returns the removed IDs of the "cards" edge to the Card entity.
func (m *ProductMutation) RemovedCardsIDs() (ids []int) {
	for id := range m.removedcards {
		ids = append(ids, id)
	}
	return
}

// CardsIDs returns the "cards" edge IDs in the mutation.
func (m *ProductMutation) CardsIDs() (ids []int) {
	for id := range m.cards {
		ids = append(ids, id)
	}
	return
}

// ResetCards resets all changes to the "cards" edge.
func (m *ProductMutation) ResetCards() {
	m.cards = nil
	m.clearedcards = false
	m.removedcards = nil
}

// ClearRevision clears the "revision" edge to the Revision entity.
func (m *ProductMutation) ClearRevision() {
	m.clearedrevision = true
}

// RevisionCleared reports if the "revision" edge to the Revision entity was cleared.
func (m *ProductMutation) RevisionCleared() bool {
	return m.clearedrevision
}

// RevisionIDs returns the "revision" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RevisionID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) RevisionIDs() (ids []int) {
	if id := m.revision; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRevision resets all changes to the "revision" edge.
func (m *ProductMutation) ResetRevision() {
	m.revision = nil
	m.clearedrevision = false
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.key != nil {
		fields = append(fields, product.FieldKey)
	}
	if m.revision != nil {
		fields = append(fields, product.FieldRevisionID)
	}
	if m.is_official_ja != nil {
		fields = append(fields, product.FieldIsOfficialJa)
	}
	if m.name_ja != nil {
		fields = append(fields, product.FieldNameJa)
	}
	if m.name_en != nil {
		fields = append(fields, product.FieldNameEn)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldKey:
		return m.Key()
	case product.FieldRevisionID:
		return m.RevisionID()
	case product.FieldIsOfficialJa:
		return m.IsOfficialJa()
	case product.FieldNameJa:
		return m.NameJa()
	case product.FieldNameEn:
		return m.NameEn()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldKey:
		return m.OldKey(ctx)
	case product.FieldRevisionID:
		return m.OldRevisionID(ctx)
	case product.FieldIsOfficialJa:
		return m.OldIsOfficialJa(ctx)
	case product.FieldNameJa:
		return m.OldNameJa(ctx)
	case product.FieldNameEn:
		return m.OldNameEn(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case product.FieldRevisionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevisionID(v)
		return nil
	case product.FieldIsOfficialJa:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOfficialJa(v)
		return nil
	case product.FieldNameJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJa(v)
		return nil
	case product.FieldNameEn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameEn(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldNameJa) {
		fields = append(fields, product.FieldNameJa)
	}
	if m.FieldCleared(product.FieldNameEn) {
		fields = append(fields, product.FieldNameEn)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldNameJa:
		m.ClearNameJa()
		return nil
	case product.FieldNameEn:
		m.ClearNameEn()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldKey:
		m.ResetKey()
		return nil
	case product.FieldRevisionID:
		m.ResetRevisionID()
		return nil
	case product.FieldIsOfficialJa:
		m.ResetIsOfficialJa()
		return nil
	case product.FieldNameJa:
		m.ResetNameJa()
		return nil
	case product.FieldNameEn:
		m.ResetNameEn()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cards != nil {
		edges = append(edges, product.EdgeCards)
	}
	if m.revision != nil {
		edges = append(edges, product.EdgeRevision)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeCards:
		ids := make([]ent.Value, 0, len(m.cards))
		for id := range m.cards {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeRevision:
		if id := m.revision; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcards != nil {
		edges = append(edges, product.EdgeCards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeCards:
		ids := make([]ent.Value, 0, len(m.removedcards))
		for id := range m.removedcards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcards {
		edges = append(edges, product.EdgeCards)
	}
	if m.clearedrevision {
		edges = append(edges, product.EdgeRevision)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeCards:
		return m.clearedcards
	case product.EdgeRevision:
		return m.clearedrevision
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeRevision:
		m.ClearRevision()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeCards:
		m.ResetCards()
		return nil
	case product.EdgeRevision:
		m.ResetRevision()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// RevisionMutation represents an operation that mutates the Revision nodes in the graph.
type RevisionMutation struct {
	config
	op              Op
	typ             string
	id              *int
	key             *string
	name_ja         *string
	name_en         *string
	clearedFields   map[string]struct{}
	cards           map[int]struct{}
	removedcards    map[int]struct{}
	clearedcards    bool
	products        map[int]struct{}
	removedproducts map[int]struct{}
	clearedproducts bool
	decks           map[int]struct{}
	removeddecks    map[int]struct{}
	cleareddecks    bool
	done            bool
	oldValue        func(context.Context) (*Revision, error)
	predicates      []predicate.Revision
}

var _ ent.Mutation = (*RevisionMutation)(nil)

// revisionOption allows management of the mutation configuration using functional options.
type revisionOption func(*RevisionMutation)

// newRevisionMutation creates new mutation for the Revision entity.
func newRevisionMutation(c config, op Op, opts ...revisionOption) *RevisionMutation {
	m := &RevisionMutation{
		config:        c,
		op:            op,
		typ:           TypeRevision,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRevisionID sets the ID field of the mutation.
func withRevisionID(id int) revisionOption {
	return func(m *RevisionMutation) {
		var (
			err   error
			once  sync.Once
			value *Revision
		)
		m.oldValue = func(ctx context.Context) (*Revision, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Revision.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRevision sets the old Revision of the mutation.
func withRevision(node *Revision) revisionOption {
	return func(m *RevisionMutation) {
		m.oldValue = func(context.Context) (*Revision, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RevisionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RevisionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RevisionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RevisionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Revision.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *RevisionMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *RevisionMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Revision entity.
// If the Revision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevisionMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *RevisionMutation) ResetKey() {
	m.key = nil
}

// SetNameJa sets the "name_ja" field.
func (m *RevisionMutation) SetNameJa(s string) {
	m.name_ja = &s
}

// NameJa returns the value of the "name_ja" field in the mutation.
func (m *RevisionMutation) NameJa() (r string, exists bool) {
	v := m.name_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJa returns the old "name_ja" field's value of the Revision entity.
// If the Revision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevisionMutation) OldNameJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJa: %w", err)
	}
	return oldValue.NameJa, nil
}

// ClearNameJa clears the value of the "name_ja" field.
func (m *RevisionMutation) ClearNameJa() {
	m.name_ja = nil
	m.clearedFields[revision.FieldNameJa] = struct{}{}
}

// NameJaCleared returns if the "name_ja" field was cleared in this mutation.
func (m *RevisionMutation) NameJaCleared() bool {
	_, ok := m.clearedFields[revision.FieldNameJa]
	return ok
}

// ResetNameJa resets all changes to the "name_ja" field.
func (m *RevisionMutation) ResetNameJa() {
	m.name_ja = nil
	delete(m.clearedFields, revision.FieldNameJa)
}

// SetNameEn sets the "name_en" field.
func (m *RevisionMutation) SetNameEn(s string) {
	m.name_en = &s
}

// NameEn returns the value of the "name_en" field in the mutation.
func (m *RevisionMutation) NameEn() (r string, exists bool) {
	v := m.name_en
	if v == nil {
		return
	}
	return *v, true
}

// OldNameEn returns the old "name_en" field's value of the Revision entity.
// If the Revision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevisionMutation) OldNameEn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameEn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameEn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameEn: %w", err)
	}
	return oldValue.NameEn, nil
}

// ClearNameEn clears the value of the "name_en" field.
func (m *RevisionMutation) ClearNameEn() {
	m.name_en = nil
	m.clearedFields[revision.FieldNameEn] = struct{}{}
}

// NameEnCleared returns if the "name_en" field was cleared in this mutation.
func (m *RevisionMutation) NameEnCleared() bool {
	_, ok := m.clearedFields[revision.FieldNameEn]
	return ok
}

// ResetNameEn resets all changes to the "name_en" field.
func (m *RevisionMutation) ResetNameEn() {
	m.name_en = nil
	delete(m.clearedFields, revision.FieldNameEn)
}

// AddCardIDs adds the "cards" edge to the Card entity by ids.
func (m *RevisionMutation) AddCardIDs(ids ...int) {
	if m.cards == nil {
		m.cards = make(map[int]struct{})
	}
	for i := range ids {
		m.cards[ids[i]] = struct{}{}
	}
}

// ClearCards clears the "cards" edge to the Card entity.
func (m *RevisionMutation) ClearCards() {
	m.clearedcards = true
}

// CardsCleared reports if the "cards" edge to the Card entity was cleared.
func (m *RevisionMutation) CardsCleared() bool {
	return m.clearedcards
}

// RemoveCardIDs removes the "cards" edge to the Card entity by IDs.
func (m *RevisionMutation) RemoveCardIDs(ids ...int) {
	if m.removedcards == nil {
		m.removedcards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cards, ids[i])
		m.removedcards[ids[i]] = struct{}{}
	}
}

// RemovedCards returns the removed IDs of the "cards" edge to the Card entity.
func (m *RevisionMutation) RemovedCardsIDs() (ids []int) {
	for id := range m.removedcards {
		ids = append(ids, id)
	}
	return
}

// CardsIDs returns the "cards" edge IDs in the mutation.
func (m *RevisionMutation) CardsIDs() (ids []int) {
	for id := range m.cards {
		ids = append(ids, id)
	}
	return
}

// ResetCards resets all changes to the "cards" edge.
func (m *RevisionMutation) ResetCards() {
	m.cards = nil
	m.clearedcards = false
	m.removedcards = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *RevisionMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *RevisionMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *RevisionMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *RevisionMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *RevisionMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *RevisionMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *RevisionMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// AddDeckIDs adds the "decks" edge to the Deck entity by ids.
func (m *RevisionMutation) AddDeckIDs(ids ...int) {
	if m.decks == nil {
		m.decks = make(map[int]struct{})
	}
	for i := range ids {
		m.decks[ids[i]] = struct{}{}
	}
}

// ClearDecks clears the "decks" edge to the Deck entity.
func (m *RevisionMutation) ClearDecks() {
	m.cleareddecks = true
}

// DecksCleared reports if the "decks" edge to the Deck entity was cleared.
func (m *RevisionMutation) DecksCleared() bool {
	return m.cleareddecks
}

// RemoveDeckIDs removes the "decks" edge to the Deck entity by IDs.
func (m *RevisionMutation) RemoveDeckIDs(ids ...int) {
	if m.removeddecks == nil {
		m.removeddecks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.decks, ids[i])
		m.removeddecks[ids[i]] = struct{}{}
	}
}

// RemovedDecks returns the removed IDs of the "decks" edge to the Deck entity.
func (m *RevisionMutation) RemovedDecksIDs() (ids []int) {
	for id := range m.removeddecks {
		ids = append(ids, id)
	}
	return
}

// DecksIDs returns the "decks" edge IDs in the mutation.
func (m *RevisionMutation) DecksIDs() (ids []int) {
	for id := range m.decks {
		ids = append(ids, id)
	}
	return
}

// ResetDecks resets all changes to the "decks" edge.
func (m *RevisionMutation) ResetDecks() {
	m.decks = nil
	m.cleareddecks = false
	m.removeddecks = nil
}

// Where appends a list predicates to the RevisionMutation builder.
func (m *RevisionMutation) Where(ps ...predicate.Revision) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RevisionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Revision).
func (m *RevisionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RevisionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.key != nil {
		fields = append(fields, revision.FieldKey)
	}
	if m.name_ja != nil {
		fields = append(fields, revision.FieldNameJa)
	}
	if m.name_en != nil {
		fields = append(fields, revision.FieldNameEn)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RevisionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case revision.FieldKey:
		return m.Key()
	case revision.FieldNameJa:
		return m.NameJa()
	case revision.FieldNameEn:
		return m.NameEn()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RevisionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case revision.FieldKey:
		return m.OldKey(ctx)
	case revision.FieldNameJa:
		return m.OldNameJa(ctx)
	case revision.FieldNameEn:
		return m.OldNameEn(ctx)
	}
	return nil, fmt.Errorf("unknown Revision field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevisionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case revision.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case revision.FieldNameJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJa(v)
		return nil
	case revision.FieldNameEn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameEn(v)
		return nil
	}
	return fmt.Errorf("unknown Revision field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RevisionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RevisionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevisionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Revision numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RevisionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(revision.FieldNameJa) {
		fields = append(fields, revision.FieldNameJa)
	}
	if m.FieldCleared(revision.FieldNameEn) {
		fields = append(fields, revision.FieldNameEn)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RevisionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RevisionMutation) ClearField(name string) error {
	switch name {
	case revision.FieldNameJa:
		m.ClearNameJa()
		return nil
	case revision.FieldNameEn:
		m.ClearNameEn()
		return nil
	}
	return fmt.Errorf("unknown Revision nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RevisionMutation) ResetField(name string) error {
	switch name {
	case revision.FieldKey:
		m.ResetKey()
		return nil
	case revision.FieldNameJa:
		m.ResetNameJa()
		return nil
	case revision.FieldNameEn:
		m.ResetNameEn()
		return nil
	}
	return fmt.Errorf("unknown Revision field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RevisionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cards != nil {
		edges = append(edges, revision.EdgeCards)
	}
	if m.products != nil {
		edges = append(edges, revision.EdgeProducts)
	}
	if m.decks != nil {
		edges = append(edges, revision.EdgeDecks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RevisionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case revision.EdgeCards:
		ids := make([]ent.Value, 0, len(m.cards))
		for id := range m.cards {
			ids = append(ids, id)
		}
		return ids
	case revision.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case revision.EdgeDecks:
		ids := make([]ent.Value, 0, len(m.decks))
		for id := range m.decks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RevisionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcards != nil {
		edges = append(edges, revision.EdgeCards)
	}
	if m.removedproducts != nil {
		edges = append(edges, revision.EdgeProducts)
	}
	if m.removeddecks != nil {
		edges = append(edges, revision.EdgeDecks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RevisionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case revision.EdgeCards:
		ids := make([]ent.Value, 0, len(m.removedcards))
		for id := range m.removedcards {
			ids = append(ids, id)
		}
		return ids
	case revision.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	case revision.EdgeDecks:
		ids := make([]ent.Value, 0, len(m.removeddecks))
		for id := range m.removeddecks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RevisionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcards {
		edges = append(edges, revision.EdgeCards)
	}
	if m.clearedproducts {
		edges = append(edges, revision.EdgeProducts)
	}
	if m.cleareddecks {
		edges = append(edges, revision.EdgeDecks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RevisionMutation) EdgeCleared(name string) bool {
	switch name {
	case revision.EdgeCards:
		return m.clearedcards
	case revision.EdgeProducts:
		return m.clearedproducts
	case revision.EdgeDecks:
		return m.cleareddecks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RevisionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Revision unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RevisionMutation) ResetEdge(name string) error {
	switch name {
	case revision.EdgeCards:
		m.ResetCards()
		return nil
	case revision.EdgeProducts:
		m.ResetProducts()
		return nil
	case revision.EdgeDecks:
		m.ResetDecks()
		return nil
	}
	return fmt.Errorf("unknown Revision edge %s", name)
}
